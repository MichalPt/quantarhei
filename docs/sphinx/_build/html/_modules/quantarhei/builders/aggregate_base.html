
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>quantarhei.builders.aggregate_base &#8212; Quantarhei 1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Quantarhei 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quantarhei.builders.aggregate_base</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class representing aggregates of molecules.</span>

<span class="sd">The class enables building of complicated objects from objects of the Molecule</span>
<span class="sd">type, their mutual interactions and system-bath interactions. It also provides</span>
<span class="sd">an interface to various methods of open quantum systems theory.</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="c1">#import h5py</span>

<span class="kn">from</span> <span class="nn">..core.managers</span> <span class="k">import</span> <span class="n">UnitsManaged</span>
<span class="c1">#from ..core.units import cm2int</span>
<span class="kn">from</span> <span class="nn">.interactions</span> <span class="k">import</span> <span class="n">dipole_dipole_interaction</span>

<span class="kn">from</span> <span class="nn">..qm.oscillators.ho</span> <span class="k">import</span> <span class="n">fcstorage</span>
<span class="kn">from</span> <span class="nn">..qm.oscillators.ho</span> <span class="k">import</span> <span class="n">operator_factory</span>

<span class="kn">from</span> <span class="nn">..qm.hilbertspace.operators</span> <span class="k">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">..qm.hilbertspace.operators</span> <span class="k">import</span> <span class="n">DensityMatrix</span>
<span class="kn">from</span> <span class="nn">..qm.hilbertspace.operators</span> <span class="k">import</span> <span class="n">ReducedDensityMatrix</span>
<span class="kn">from</span> <span class="nn">..qm.propagators.dmevolution</span> <span class="k">import</span> <span class="n">ReducedDensityMatrixEvolution</span>
<span class="kn">from</span> <span class="nn">..qm.liouvillespace.systembathinteraction</span> <span class="k">import</span> <span class="n">SystemBathInteraction</span>
<span class="kn">from</span> <span class="nn">..qm.hilbertspace.hamiltonian</span> <span class="k">import</span> <span class="n">Hamiltonian</span>
<span class="kn">from</span> <span class="nn">..qm.hilbertspace.dmoment</span> <span class="k">import</span> <span class="n">TransitionDipoleMoment</span>

<span class="kn">from</span> <span class="nn">..qm.corfunctions</span> <span class="k">import</span> <span class="n">CorrelationFunctionMatrix</span>

<span class="c1">#from .aggregate_states import aggregate_state</span>
<span class="kn">from</span> <span class="nn">.aggregate_states</span> <span class="k">import</span> <span class="n">ElectronicState</span>
<span class="kn">from</span> <span class="nn">.aggregate_states</span> <span class="k">import</span> <span class="n">VibronicState</span>

<span class="c1">#from ..core.managers import energy_units</span>
<span class="c1">#from .molecules import Molecule</span>
<span class="kn">from</span> <span class="nn">..core.managers</span> <span class="k">import</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">..core.saveable</span> <span class="k">import</span> <span class="n">Saveable</span>

<span class="kn">import</span> <span class="nn">quantarhei</span> <span class="k">as</span> <span class="nn">qr</span>

          
<div class="viewcode-block" id="AggregateBase"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase">[docs]</a><span class="k">class</span> <span class="nc">AggregateBase</span><span class="p">(</span><span class="n">UnitsManaged</span><span class="p">,</span> <span class="n">Saveable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Molecular aggregate </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    name : str</span>
<span class="sd">        Specifies the name of the aggregate</span>
<span class="sd">        </span>
<span class="sd">    molecules : list or tuple</span>
<span class="sd">        List of molecules out of which the aggregate is built</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span> <span class="o">=</span> <span class="p">[]</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">=</span> <span class="mi">0</span>         <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>       <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span>          <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_egcf_matrix</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_lindich_axes</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">molecules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">molecules</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_Molecule</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_me</span><span class="p">()</span>  


    <span class="k">def</span> <span class="nf">_init_me</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes all built attributes of the aggregate</span>
<span class="sd">        </span>
<span class="sd">        This should put the object into a pre-build state</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="o">=</span> <span class="n">fcstorage</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="n">operator_factory</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_relaxation_tensor</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_relaxation_theory</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="c1">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_built</span> <span class="o">=</span> <span class="kc">False</span>     <span class="c1">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span>                <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbi_mult</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span> <span class="o">=</span> <span class="mi">0</span>                 <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span> <span class="o">=</span> <span class="mi">0</span>                <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span> <span class="o">=</span> <span class="mi">0</span>                  <span class="c1">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elsigs</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">HH</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HamOp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DD</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D2_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span> <span class="o">=</span> <span class="kc">None</span>
        
        
<div class="viewcode-block" id="AggregateBase.clean"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cleans the aggregate object of anything built</span>
<span class="sd">        </span>
<span class="sd">        This operation leaves the molecules of the aggregate intact and keeps</span>
<span class="sd">        few more pieces of information it it. E. g. coupling matrix is not </span>
<span class="sd">        deleted. You call build again after this.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_me</span><span class="p">()</span></div>
        
    
<div class="viewcode-block" id="AggregateBase.wipe_out"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.wipe_out">[docs]</a>    <span class="k">def</span> <span class="nf">wipe_out</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes everything except of name attribute</span>
<span class="sd">        </span>
<span class="sd">        You have to set molecules and recalculate interactions before you can</span>
<span class="sd">        build</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span> <span class="o">=</span> <span class="p">{}</span>   <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">=</span> <span class="mi">0</span>      <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbi_mult</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_egcf_matrix</span> <span class="o">=</span> <span class="kc">False</span>   <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#</span>
       
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span> <span class="o">=</span> <span class="kc">False</span>     <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_me</span><span class="p">()</span>        </div>


    <span class="k">def</span> <span class="nf">_before_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_after_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_after_load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
        

    <span class="c1">########################################################################</span>
    <span class="c1">#</span>
    <span class="c1">#    BUILDING METHODS</span>
    <span class="c1">#</span>
    <span class="c1">########################################################################</span>

<div class="viewcode-block" id="AggregateBase.init_coupling_matrix"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.init_coupling_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">init_coupling_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Nullifies coupling matrix</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">),</span>
                                              <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span> <span class="o">=</span> <span class="kc">True</span>  </div>
        <span class="c1"># </span>
        <span class="c1"># TESTED</span>

    
<div class="viewcode-block" id="AggregateBase.set_resonance_coupling"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.set_resonance_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">set_resonance_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">coupling</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets resonance coupling value between two sites</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_coupling_matrix</span><span class="p">()</span> 
            
        <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_internal_u</span><span class="p">(</span><span class="n">coupling</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coup</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>
 
       
<div class="viewcode-block" id="AggregateBase.get_resonance_coupling"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_resonance_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">get_resonance_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns resonance coupling value between two sites</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coupling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_current_u</span><span class="p">(</span><span class="n">coupling</span><span class="p">)</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>


<div class="viewcode-block" id="AggregateBase.set_resonance_coupling_matrix"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.set_resonance_coupling_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_resonance_coupling_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coupmat</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;Sets resonance coupling values from a matrix</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">coupmat</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">coupmat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coupmat</span><span class="p">)</span>
            
        <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_internal_u</span><span class="p">(</span><span class="n">coupmat</span><span class="p">)</span>           
        <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span> <span class="o">=</span> <span class="n">coup</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span> <span class="o">=</span> <span class="kc">True</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>
            
            
<div class="viewcode-block" id="AggregateBase.dipole_dipole_coupling"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.dipole_dipole_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">dipole_dipole_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="n">epsr</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates dipole-dipole coupling </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kk</span> <span class="o">==</span> <span class="n">ll</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only coupling between different molecules </span><span class="se">\</span>
<span class="s2">            can be calculated&quot;</span><span class="p">)</span>
        
        <span class="c1">#FIXME: this works only for first excited states of two-level molecules</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span><span class="o">.</span><span class="n">dmoments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span><span class="o">.</span><span class="n">dmoments</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>        

        <span class="n">val</span> <span class="o">=</span>  <span class="n">dipole_dipole_interaction</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">epsr</span><span class="p">)</span>            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_current_u</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>


<div class="viewcode-block" id="AggregateBase.set_coupling_by_dipole_dipole"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.set_coupling_by_dipole_dipole">[docs]</a>    <span class="k">def</span> <span class="nf">set_coupling_by_dipole_dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsr</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets resonance coupling by dipole-dipole interaction</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_coupling_matrix</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kk</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">):</span>
                <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dipole_dipole_coupling</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span><span class="n">ll</span><span class="p">,</span><span class="n">epsr</span><span class="o">=</span><span class="n">epsr</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_internal_u</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">ll</span><span class="p">,</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>

                
<div class="viewcode-block" id="AggregateBase.calculate_resonance_coupling"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.calculate_resonance_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_resonance_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dipole-dipole&quot;</span><span class="p">,</span>
                               <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">epsr</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Sets resonance coupling calculated by a given method </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        method: string</span>
<span class="sd">            Method to be used for calculation of resonance coupling</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;dipole-dipole&quot;</span><span class="p">:</span>
            <span class="n">epsr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;epsr&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_coupling_by_dipole_dipole</span><span class="p">(</span><span class="n">epsr</span><span class="o">=</span><span class="n">epsr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown method for calculation&quot;</span><span class="o">+</span>
                            <span class="s2">&quot; of resonance coupling&quot;</span><span class="p">)</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>

    
    <span class="c1"># FIXME: This must be set in coordination with objects describing laboratory</span>
<div class="viewcode-block" id="AggregateBase.set_lindich_axes"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.set_lindich_axes">[docs]</a>    <span class="k">def</span> <span class="nf">set_lindich_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_orthog_membrane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a coordinate system with one axis supplied by the user </span>
<span class="sd">        (typically an axis orthogonal to the membrane), and two other axes, all </span>
<span class="sd">        of which are orthonormal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
       
        <span class="n">qr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">axis_orthog_membrane</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_lindich_axes</span> <span class="o">=</span> <span class="kc">True</span>       </div>
    
    <span class="c1"># FIXME: This must be set in coordination with objects describing laboratory    </span>
    <span class="k">def</span> <span class="nf">get_lindich_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_lindich_axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No linear dichroism coordinate system supplied&quot;</span><span class="p">)</span>
    
    
    <span class="c1"># FIXME: This should be delegated SystemBathInteraction</span>
<div class="viewcode-block" id="AggregateBase.set_egcf_matrix"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.set_egcf_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_egcf_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets a matrix describing system bath interaction</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span> <span class="o">=</span> <span class="n">cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_egcf_matrix</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="c1">#</span>
    <span class="c1"># Molecues</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="AggregateBase.add_Molecule"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.add_Molecule">[docs]</a>    <span class="k">def</span> <span class="nf">add_Molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mono</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds monomer to the aggregate</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># If at least one monomer has energy gap correlation function</span>
        <span class="c1"># we will try to build system bath interaction for a the aggregate.</span>
        <span class="c1"># Exception will be thrown if not all monomers have the same egcf</span>
        <span class="k">if</span> <span class="n">mono</span><span class="o">.</span><span class="n">_has_egcf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span> <span class="o">=</span> <span class="kc">True</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mono</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">mono</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">+=</span> <span class="mi">1</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>


    <span class="k">def</span> <span class="nf">get_Molecule_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>    

  
    <span class="k">def</span> <span class="nf">get_Molecule_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">im</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>         


    <span class="k">def</span> <span class="nf">remove_Molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mono</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">mono</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">-=</span> <span class="mi">1</span>


<div class="viewcode-block" id="AggregateBase.get_nearest_Molecule"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_nearest_Molecule">[docs]</a>    <span class="k">def</span> <span class="nf">get_nearest_Molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">molecule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a molecule nearest in the aggregate to a given molecule</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        molecule : Molecule</span>
<span class="sd">            Molecule whose neighbor we look for</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-3</span>
        <span class="n">rmin</span> <span class="o">=</span> <span class="mf">1.0e20</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">position</span>
        <span class="n">mmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">position</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="n">r2</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">rmin</span><span class="p">):</span>
                <span class="n">mmin</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">rmin</span> <span class="o">=</span> <span class="n">dist</span>
                
        <span class="k">return</span> <span class="n">mmin</span><span class="p">,</span> <span class="n">rmin</span>        </div>
            
    <span class="c1">#</span>
    <span class="c1"># Vibrational modes</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">add_Mode_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
            <span class="n">mn</span><span class="o">.</span><span class="n">add_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
            
    <span class="k">def</span> <span class="nf">get_Mode_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">mn</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mode not found&quot;</span><span class="p">)</span>   
            
    <span class="c1">#</span>
    <span class="c1"># Transition dipole</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">get_dipole_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">mn</span><span class="o">.</span><span class="n">get_dipole</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
     
    <span class="k">def</span> <span class="nf">get_dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="n">nm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nm</span><span class="o">.</span><span class="n">get_dipole</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
    
    
    <span class="c1">#</span>
    <span class="c1"># Various info</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">get_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="n">nm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nm</span><span class="o">.</span><span class="n">get_transition_width</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">))</span>
    
    
<div class="viewcode-block" id="AggregateBase.get_max_excitations"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_max_excitations">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_excitations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of maximum number of excitations on each monomer</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">omax</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">:</span>
            <span class="n">omax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nm</span><span class="o">.</span><span class="n">nel</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">omax</span></div>
        
  
<div class="viewcode-block" id="AggregateBase.get_energy_by_name"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_energy_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_energy_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Electronic energy &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">mn</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="AggregateBase.fc_factor"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.fc_factor">[docs]</a>    <span class="k">def</span> <span class="nf">fc_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Franck-Condon factors between two vibrational states</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Calculates Franck-Condon factor between two aggregate_states</span>
<span class="sd">        regardless of their electronic parts</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">inx1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">vsig</span>
        <span class="n">inx2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">vsig</span>
        <span class="n">sta1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">vibmodes</span>
        <span class="n">sta2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">vibmodes</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sta1</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">sta2</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Incompatible states&quot;</span><span class="p">)</span>
            
        <span class="n">res</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sta1</span><span class="p">)):</span>
            <span class="n">smod1</span> <span class="o">=</span> <span class="n">sta1</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
            <span class="n">smod2</span> <span class="o">=</span> <span class="n">sta2</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
            
            <span class="c1"># difference in shifts</span>
            <span class="n">shft</span> <span class="o">=</span> <span class="n">smod1</span><span class="o">.</span><span class="n">shift</span> <span class="o">-</span> <span class="n">smod2</span><span class="o">.</span><span class="n">shift</span>
            <span class="c1"># quantum numbers</span>
            <span class="n">qn1</span> <span class="o">=</span> <span class="n">inx1</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
            <span class="n">qn2</span> <span class="o">=</span> <span class="n">inx2</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>

            <span class="c1">#calculate FC factors</span>
            <span class="c1">#</span>
            <span class="c1">#Best implementation would be a table look-up. First we calculate</span>
            <span class="c1">#a table of FC factors from known omegas and shifts and here we</span>
            <span class="c1">#just consult the table.</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">shft</span><span class="p">):</span>
                <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">shift_operator</span><span class="p">(</span><span class="n">shft</span><span class="p">)[:</span><span class="mi">20</span><span class="p">,:</span><span class="mi">20</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">shft</span><span class="p">,</span><span class="n">fc</span><span class="p">)</span>
                
            <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">shft</span><span class="p">)</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ii</span><span class="p">)[</span><span class="n">qn1</span><span class="p">,</span><span class="n">qn2</span><span class="p">]</span>
            
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">*</span><span class="n">rs</span>
            
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="AggregateBase.get_transition_width"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_transition_width">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns phenomenological width of a given transition</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        state1 : {ElectroniState/VibronicState, tuple}</span>
<span class="sd">            If both state1 and state2 are specified, it is assumed they are</span>
<span class="sd">            of the type of Electronic of Vibronic state. Otherwise, if state2</span>
<span class="sd">            is None, it is assumed that it is a tuple representing </span>
<span class="sd">            a transition</span>
<span class="sd">            </span>
<span class="sd">        state2 : {ElectroniState/VibronicState, None}</span>
<span class="sd">        If not None it is of the type of Electronic of Vibronic state</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">b1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">band</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">band</span>
            
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b2</span><span class="o">-</span><span class="n">b1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            
                <span class="c1"># index of a monomer on which the transition occurs</span>
                <span class="n">exindx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_exindx</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
                <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">exindx</span><span class="p">]</span><span class="o">.</span><span class="n">get_transition_width</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="c1">#print(exindx, width)</span>
                <span class="k">return</span> <span class="n">width</span>
            
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b2</span><span class="o">-</span><span class="n">b1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                
                <span class="p">(</span><span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_twoexindx</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
                <span class="c1">#print(state1.elstate.elsignature, </span>
                <span class="c1">#      state2.elstate.elsignature, indx1, indx2)</span>
                <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">indx1</span><span class="p">]</span><span class="o">.</span><span class="n">get_transition_width</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">width</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">indx2</span><span class="p">]</span><span class="o">.</span><span class="n">get_transition_width</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="c1">#print(indx1, indx2, width)</span>
                <span class="k">return</span> <span class="n">width</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
            

        <span class="k">else</span><span class="p">:</span> 
            
            <span class="n">transition</span> <span class="o">=</span> <span class="n">state1</span>
        
            <span class="n">Nf</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Ni</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">eli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">Ni</span><span class="p">]</span>
            <span class="n">elf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">Nf</span><span class="p">]</span>
            
            <span class="c1"># g -&gt; 1 exciton band transitions</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">eli</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elf</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># this simulates bath correlation function</span>
                <span class="c1">#print(&quot;0-&gt;1 :&quot;, self.Wd[Nf, Nf]**2)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">Nf</span><span class="p">,</span> <span class="n">Nf</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="c1"># 1 exciton -&gt; 2 exciton transitions</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">eli</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elf</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># this simulates the term  g_ff + g_ee - 2Re g_fe</span>
                <span class="n">ret</span> <span class="o">=</span>  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Ni</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">Nf</span><span class="p">,</span> <span class="n">Nf</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                        <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">Nf</span><span class="p">,</span> <span class="n">Ni</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="c1">#print(&quot;1-&gt;2 (&quot;, eli, elf,&quot;) :&quot;, ret, self.Wd[Nf, Ni]**2)</span>
                <span class="k">return</span> <span class="n">ret</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This should not be used&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="AggregateBase.get_transition_dephasing"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_transition_dephasing">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition_dephasing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns phenomenological dephasing of a given transition</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        state1 : {ElectroniState/VibronicState, tuple}</span>
<span class="sd">            If both state1 and state2 are specified, it is assumed they are</span>
<span class="sd">            of the type of Electronic of Vibronic state. Otherwise, if state2</span>
<span class="sd">            is None, it is assumed that it is a tuple representing </span>
<span class="sd">            a transition</span>
<span class="sd">            </span>
<span class="sd">        state2 : {ElectroniState/VibronicState, None}</span>
<span class="sd">        If not None it is of the type of Electronic of Vibronic state</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="c1"># index of a monomer on which the transition occurs</span>
            <span class="n">exindx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_exindx</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exindx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            
            <span class="n">deph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">exindx</span><span class="p">]</span><span class="o">.</span><span class="n">get_transition_dephasing</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">deph</span>
    
        <span class="k">else</span><span class="p">:</span> 
            
            <span class="n">transition</span> <span class="o">=</span> <span class="n">state1</span>
        
            <span class="n">Nf</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Ni</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">eli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">Ni</span><span class="p">]</span>
            <span class="n">elf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">Nf</span><span class="p">]</span>
            
            <span class="c1"># g -&gt; 1 exciton band transitions</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">eli</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elf</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dr</span><span class="p">[</span><span class="n">Nf</span><span class="p">,</span> <span class="n">Nf</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="c1"># 1 exciton -&gt; 2 exciton band transitions</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">eli</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elf</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># this simulates the term  g_ff + g_ee - 2Re g_fe</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dr</span><span class="p">[</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Ni</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dr</span><span class="p">[</span><span class="n">Nf</span><span class="p">,</span> <span class="n">Nf</span><span class="p">]</span>
                        <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Dr</span><span class="p">[</span><span class="n">Nf</span><span class="p">,</span> <span class="n">Ni</span><span class="p">])</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span></div>


<div class="viewcode-block" id="AggregateBase.transition_dipole"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.transition_dipole">[docs]</a>    <span class="k">def</span> <span class="nf">transition_dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transition dipole moment between two states </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state1 : class VibronicState</span>
<span class="sd">            state 1</span>
<span class="sd">            </span>
<span class="sd">        state2 : class VibronicState</span>
<span class="sd">            state 2 </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exindx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_exindx</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">exindx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        
        <span class="n">eldip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dipole</span><span class="p">(</span><span class="n">exindx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
           
        <span class="c1"># Franck-Condon factor between the two states</span>
        <span class="n">fcfac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_factor</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span><span class="n">state2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">eldip</span><span class="o">*</span><span class="n">fcfac</span></div>

    <span class="k">def</span> <span class="nf">_get_twoexindx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices of two molecule with transitions or negative number</span>
<span class="sd">        if not found</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state1 : class VibronicState</span>
<span class="sd">            state 1</span>
<span class="sd">            </span>
<span class="sd">        state2 : class VibronicState</span>
<span class="sd">            state 2 </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get electronic signatures</span>
        <span class="n">els1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">elsignature</span>
        <span class="n">els2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">elsignature</span>  
        
        <span class="c1"># only states in neighboring bands can be connected by dipole moment</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">band</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">band</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">b1</span><span class="o">-</span><span class="n">b2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># count the number of differences</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">els1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kk</span> <span class="o">!=</span> <span class="n">els2</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
                
                
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># now that we know that the states differ by two excitations, let</span>
        <span class="c1"># us find on which molecule they are</span>
        <span class="n">exstates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exindxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">els1</span><span class="p">:</span> <span class="c1"># signature is just a tuple; iterate over it  </span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">kk</span> <span class="o">!=</span> <span class="n">els2</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span> <span class="c1"># this is the index where they differ</span>
                <span class="c1"># which of them is excited</span>
                <span class="k">if</span> <span class="n">kk</span> <span class="o">&gt;</span> <span class="n">els2</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                    <span class="n">exstates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">els1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exstates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">els2</span><span class="p">)</span>
                <span class="n">exindxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exstates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">exindxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exindxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">_get_exindx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Index of molecule with transition or negative number if not found</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state1 : class VibronicState</span>
<span class="sd">            state 1</span>
<span class="sd">            </span>
<span class="sd">        state2 : class VibronicState</span>
<span class="sd">            state 2 </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># get electronic signatures</span>
        <span class="n">els1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">elsignature</span>
        <span class="n">els2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">elsignature</span>  
        
        <span class="c1"># only states in neighboring bands can be connected by dipole moment</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">band</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">band</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">b1</span><span class="o">-</span><span class="n">b2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># count the number of differences</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">els1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kk</span> <span class="o">!=</span> <span class="n">els2</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
                
                
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="c1"># now that we know that the states differ by one excitation, let</span>
        <span class="c1"># us find on which molecule it is</span>
        <span class="n">exstate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">els1</span><span class="p">:</span> <span class="c1"># signature is just a tuple; iterate over it  </span>
            <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">kk</span> <span class="o">!=</span> <span class="n">els2</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span> <span class="c1"># this is the index where they differ</span>
                <span class="c1"># which of them is excited</span>
                <span class="k">if</span> <span class="n">kk</span> <span class="o">&gt;</span> <span class="n">els2</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                    <span class="n">exstate</span> <span class="o">=</span> <span class="n">els1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exstate</span> <span class="o">=</span> <span class="n">els2</span>
                <span class="n">exindx</span> <span class="o">=</span> <span class="n">l</span>
            
        <span class="k">if</span> <span class="n">exstate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">exindx</span>
    
        
<div class="viewcode-block" id="AggregateBase.total_number_of_states"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.total_number_of_states">[docs]</a>    <span class="k">def</span> <span class="nf">total_number_of_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vibgen_approx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Total number of states in the aggregate</span>
<span class="sd">        </span>
<span class="sd">        Counts all states of the aggregate by iterating through them. States</span>
<span class="sd">        are generated with a set of constraints.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">nret</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allstates</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span>
                                    <span class="n">save_indices</span><span class="o">=</span><span class="n">save_indices</span><span class="p">,</span>
                                    <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span>
                                    <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span> 
                                    <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">):</span>
            <span class="n">nret</span> <span class="o">+=</span> <span class="mi">1</span>
                
        <span class="k">return</span> <span class="n">nret</span></div>


<div class="viewcode-block" id="AggregateBase.total_number_of_electronic_states"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.total_number_of_electronic_states">[docs]</a>    <span class="k">def</span> <span class="nf">total_number_of_electronic_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Total number of electronic states in the aggregate&quot;&quot;&quot;</span>
        
        <span class="n">nret</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">elsig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elsignatures</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">):</span>
            <span class="n">nret</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="k">return</span> <span class="n">nret</span></div>

 
<div class="viewcode-block" id="AggregateBase.number_of_states_in_band"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.number_of_states_in_band">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_states_in_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vibgen_approx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">Nvib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of states in a given excitonic band &quot;&quot;&quot;</span>
        
        <span class="n">nret</span> <span class="o">=</span> <span class="mi">0</span>
                    
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allstates</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">band</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;EQ&quot;</span><span class="p">,</span> <span class="n">save_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span>
                                    <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">):</span>
            <span class="n">nret</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="k">return</span> <span class="n">nret</span></div>


<div class="viewcode-block" id="AggregateBase.number_of_electronic_states_in_band"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.number_of_electronic_states_in_band">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_electronic_states_in_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of states in a given excitonic band &quot;&quot;&quot;</span>
        
        <span class="n">nret</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">elsig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elsignatures</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">band</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;EQ&quot;</span><span class="p">):</span>
            <span class="n">nv</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">nret</span> <span class="o">+=</span> <span class="n">nv</span>
            
        <span class="k">return</span> <span class="n">nret</span></div>
    
    
<div class="viewcode-block" id="AggregateBase.get_ElectronicState"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_ElectronicState">[docs]</a>    <span class="k">def</span> <span class="nf">get_ElectronicState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns electronic state corresponding to this aggregate</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        sig : tuple</span>
<span class="sd">            Tuple defining the electronic state of the aggregate</span>
<span class="sd">            </span>
<span class="sd">        index : integer or None</span>
<span class="sd">            If integer is specified, this number is recorded as an index</span>
<span class="sd">            of this state in the aggregate. It is recorded only internally</span>
<span class="sd">            in the state object. Aggregate keeps its own record which is</span>
<span class="sd">            created during the build.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ElectronicState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="AggregateBase.get_VibronicState"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_VibronicState">[docs]</a>    <span class="k">def</span> <span class="nf">get_VibronicState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">esig</span><span class="p">,</span> <span class="n">vsig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vibronic state corresponding to the two specified signatures</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ElectronicState</span><span class="p">(</span><span class="n">sig</span><span class="o">=</span><span class="n">esig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VibronicState</span><span class="p">(</span><span class="n">elstate</span><span class="p">,</span> <span class="n">vsig</span><span class="p">)</span> </div>
    
    
<div class="viewcode-block" id="AggregateBase.coupling"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.coupling">[docs]</a>    <span class="k">def</span> <span class="nf">coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coupling between two aggregate states </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        state1 : {ElectronicState, VibronicState}</span>
<span class="sd">            States for which coupling should be calculated</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#</span>
        <span class="c1"># Coupling between two purely electronic states</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">ElectronicState</span><span class="p">)</span> 
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state2</span><span class="p">,</span> <span class="n">ElectronicState</span><span class="p">)):</span>
                        
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># coupling within the bands</span>
                <span class="k">if</span> <span class="n">state1</span><span class="o">.</span><span class="n">band</span> <span class="o">==</span> <span class="n">state2</span><span class="o">.</span><span class="n">band</span><span class="p">:</span>
                    
                    <span class="k">if</span> <span class="n">state1</span><span class="o">.</span><span class="n">band</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        
                        <span class="n">kk</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">ll</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                        
                        <span class="k">if</span> <span class="p">(</span><span class="n">kk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span><span class="n">ll</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>

                    <span class="k">else</span><span class="p">:</span>
                        
                        <span class="n">els1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elsignature</span>
                        <span class="n">els2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elsignature</span>
                        <span class="n">Ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">els1</span><span class="p">)</span>
                        <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="c1"># count differences</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">els1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">els2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                                    <span class="n">sites</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># if there are exactly 2 differences, the differing</span>
                        <span class="c1"># two molecules are those coupled; sites[k] contains</span>
                        <span class="c1"># indiced those coupled molecules</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">kk</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">ll</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span><span class="n">ll</span><span class="p">]</span>   
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
                            
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
    
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
            
        <span class="c1">#</span>
        <span class="c1"># Coupling between two general states</span>
        <span class="c1">#</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">VibronicState</span><span class="p">)</span> 
          <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state2</span><span class="p">,</span> <span class="n">VibronicState</span><span class="p">)):</span>
              
            <span class="n">es1</span> <span class="o">=</span> <span class="n">state1</span><span class="o">.</span><span class="n">elstate</span>
            <span class="n">es2</span> <span class="o">=</span> <span class="n">state2</span><span class="o">.</span><span class="n">elstate</span>
            
            <span class="n">fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_factor</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
            
            <span class="c1"># it make sense to calculate coupling only when the number</span>
            <span class="c1"># of molecules is larger than 1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                <span class="c1"># coupling within the bands</span>
                <span class="k">if</span> <span class="n">es1</span><span class="o">.</span><span class="n">band</span> <span class="o">==</span> <span class="n">es2</span><span class="o">.</span><span class="n">band</span><span class="p">:</span>
                    
                    <span class="c1"># single exciton band</span>
                    <span class="k">if</span> <span class="n">es1</span><span class="o">.</span><span class="n">band</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        
                        <span class="n">kk</span> <span class="o">=</span> <span class="n">es1</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">ll</span> <span class="o">=</span> <span class="n">es2</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                    
                        <span class="k">if</span> <span class="p">(</span><span class="n">kk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span><span class="n">ll</span><span class="p">]</span><span class="o">*</span><span class="n">fc</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        
                        <span class="n">els1</span> <span class="o">=</span> <span class="n">es1</span><span class="o">.</span><span class="n">elsignature</span>
                        <span class="n">els2</span> <span class="o">=</span> <span class="n">es2</span><span class="o">.</span><span class="n">elsignature</span>
                        <span class="n">Ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">els1</span><span class="p">)</span>
                        <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="c1"># count differences</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">els1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">els2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                                    <span class="n">sites</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># if there are exactly 2 differences, the differing</span>
                        <span class="c1"># two molecules are those coupled; sites[k] contains</span>
                        <span class="c1"># indiced those coupled molecules</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">kk</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">ll</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span><span class="n">ll</span><span class="p">]</span><span class="o">*</span><span class="n">fc</span>    
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
                        
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coup</span> <span class="o">=</span> <span class="mf">0.0</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_current_u</span><span class="p">(</span><span class="n">coup</span><span class="p">)</span></div>
    
    
    
    <span class="c1">#######################################################################</span>
    <span class="c1">#</span>
    <span class="c1"># Generators</span>
    <span class="c1">#</span>
    <span class="c1">#######################################################################</span>

<div class="viewcode-block" id="AggregateBase.elsignatures"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.elsignatures">[docs]</a>    <span class="k">def</span> <span class="nf">elsignatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;LQ&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generator of electronic signatures </span>
<span class="sd">        </span>
<span class="sd">        Here we create signature tuples of electronic states. The signature</span>
<span class="sd">        is a tuple with as many integer numbers as the members of</span>
<span class="sd">        the aggregate. Each integer represents the state in which the </span>
<span class="sd">        member of the aggregate is, e.g. 0 for ground state, 1 for the first</span>
<span class="sd">        excited state etc.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mult : int</span>
<span class="sd">            multiplicity of excitons</span>
<span class="sd">            </span>
<span class="sd">        mode : str {&quot;LQ&quot;, &quot;EQ&quot;}</span>
<span class="sd">            mode of the functions.</span>
<span class="sd">            </span>
<span class="sd">            mode=&quot;LQ&quot; returns all signatures of states with </span>
<span class="sd">            multiplicity less than or equal to the `mult`  </span>
<span class="sd">           </span>
<span class="sd">            mode=&quot;EQ&quot; returns signatures of states with a multiplicity</span>
<span class="sd">            given by `mult`</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LQ&quot;</span><span class="p">,</span><span class="s2">&quot;EQ&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown mode&quot;</span><span class="p">)</span>
            
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">)</span>

        <span class="c1"># list of maximum numbers of excitations on each sites</span>
        <span class="n">omax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_excitations</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">mult</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;mult must be larger than or equal to zero&quot;</span><span class="p">)</span>
            
        <span class="n">mlt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># iterate over all excition multiplicities</span>
        <span class="k">while</span> <span class="n">mlt</span> <span class="o">&lt;=</span> <span class="n">mult</span><span class="p">:</span>
            <span class="c1"># no excitations (ground state)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
            <span class="c1"># if this is the multiplicity 0, yield the ground state</span>
            <span class="k">if</span> <span class="p">(((</span><span class="n">mlt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;LQ&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mult</span><span class="o">==</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># first we have only ground state signature</span>
                <span class="n">ins</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
                <span class="n">strt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">mlt</span><span class="p">:</span>
                    <span class="n">nins</span> <span class="o">=</span> <span class="p">[]</span> 
                    <span class="n">nstr</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># take all signatures in &quot;ins&quot; and add one excitation</span>
                    <span class="k">for</span> <span class="n">out_added</span><span class="p">,</span> <span class="n">last</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_excitation</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span><span class="n">strt</span><span class="p">,</span><span class="n">omax</span><span class="p">):</span>
                        <span class="c1"># if mlt excitation was added yield</span>
                        <span class="k">if</span> <span class="p">(((</span><span class="n">k</span> <span class="o">==</span> <span class="n">mlt</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;LQ&quot;</span><span class="p">))</span>
                          <span class="ow">or</span><span class="p">((</span><span class="n">mult</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mult</span> <span class="o">==</span> <span class="n">mlt</span><span class="p">))):</span> 
                            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_added</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># make a list of all new signatures</span>
                            <span class="n">nins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_added</span><span class="p">)</span>
                            <span class="c1"># for each signature, save the index</span>
                            <span class="c1"># on which an excitation was added last</span>
                            <span class="n">nstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
                    <span class="c1"># set the new signatures for processing in the iteration</span>
                    <span class="n">ins</span> <span class="o">=</span> <span class="n">nins</span>
                    <span class="n">strt</span> <span class="o">=</span> <span class="n">nstr</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">mlt</span> <span class="o">+=</span> <span class="mi">1</span></div>
            
                    
    <span class="k">def</span> <span class="nf">_add_excitation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inlists</span><span class="p">,</span> <span class="n">strt</span><span class="p">,</span> <span class="n">omax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds one excitation to all submitted electronic signatures&quot;&quot;&quot;</span>
        
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># go through all signatures</span>
        <span class="k">for</span> <span class="n">inlist</span> <span class="ow">in</span> <span class="n">inlists</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inlist</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">omax</span><span class="p">)</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;arg omax has to be a list of the same </span><span class="se">\</span>
<span class="s2">                length as arg inlist&quot;</span><span class="p">)</span>
            <span class="c1"># go through all positions from the last index on (in order </span>
            <span class="c1"># to create unique signatures)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">strt</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">l</span><span class="p">):</span>
                <span class="c1"># if it is possible to add and excitation</span>
                <span class="c1"># make a new list and add</span>
                <span class="k">if</span> <span class="n">inlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">omax</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">inlist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># yield the list and the index of the last added exitation</span>
                    <span class="k">yield</span> <span class="n">out</span><span class="p">,</span> <span class="n">i</span>  
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    
<div class="viewcode-block" id="AggregateBase.vibsignatures"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.vibsignatures">[docs]</a>    <span class="k">def</span> <span class="nf">vibsignatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elsignature</span><span class="p">,</span> <span class="n">approx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generator of vibrational signatures </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        approx : None or str</span>
<span class="sd">            Approximation used in generation of vibrational states</span>
<span class="sd">            Allowed values are None or &quot;SPA&quot;</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">ElectronicState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elsignature</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cs</span><span class="o">.</span><span class="n">vsignatures</span><span class="p">(</span><span class="n">approx</span><span class="o">=</span><span class="n">approx</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="AggregateBase.allstates"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.allstates">[docs]</a>    <span class="k">def</span> <span class="nf">allstates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;LQ&quot;</span><span class="p">,</span> <span class="n">all_vibronic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                  <span class="n">save_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vibgen_approx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generator of all aggregate states</span>
<span class="sd">        </span>
<span class="sd">        Iterator generating all states of the aggregate given a set</span>
<span class="sd">        of constraints.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        mult : integer {0, 1, 2}</span>
<span class="sd">            Exciton multiplicity (ground state, single and double excitons). </span>
<span class="sd">            All excitons with the multiplicity smaller or equal to ``mult``</span>
<span class="sd">            are generated by default</span>
<span class="sd">            </span>
<span class="sd">        mode : str {&quot;LQ&quot;, &quot;EQ&quot;}</span>
<span class="sd">            If set to &quot;LQ&quot; generates excitons with smaller or equal </span>
<span class="sd">            multiplicity than specified. If &quot;EQ&quot; is specified, generates only</span>
<span class="sd">            excitons with given multiplicity</span>
<span class="sd">            </span>
<span class="sd">        save_indices : bool</span>
<span class="sd">            If True, saves indices of all generated states, so that they can</span>
<span class="sd">            be later used.</span>
<span class="sd">            </span>
<span class="sd">        all_vibronic : bool</span>
<span class="sd">            If True, all generated states are of the type ``VibronicState``,</span>
<span class="sd">            even if no vibrational modes are specified. If False,</span>
<span class="sd">            ``ElectronicState`` is returned for pure electronic states</span>
<span class="sd">            </span>
<span class="sd">        vibgen_approx : str {&quot;ZPA&quot;, &quot;SPA&quot;, &quot;TPA&quot;, &quot;NPA&quot;, &quot;SPPMA&quot;, &quot;TPPMA&quot;, &quot;NPPMA&quot;}</span>
<span class="sd">            Type of approximation in generating vibrational states</span>
<span class="sd">            </span>
<span class="sd">        Nvib : integer</span>
<span class="sd">            Number of vibrational states that goes into &quot;NPA&quot; and &quot;NPPMA&quot; </span>
<span class="sd">            approximations</span>
<span class="sd">            </span>
<span class="sd">        vibenergy_cutoff: float</span>
<span class="sd">            Maximum vibrational energy allowed in generation of vibrational</span>
<span class="sd">            states</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ast</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index counting all states</span>
        <span class="n">ist</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index counting electronic states</span>
        
        <span class="c1"># run over all electronic signatures</span>
        <span class="k">for</span> <span class="n">ess1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elsignatures</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">):</span>
            
            <span class="c1"># generate electronic state</span>
            <span class="n">es1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ElectronicState</span><span class="p">(</span><span class="n">ess1</span><span class="p">,</span> <span class="n">ist</span><span class="p">)</span>
            
            <span class="c1"># loop over all vibrational signatures in electronic states</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">vsig1</span> <span class="ow">in</span> <span class="n">es1</span><span class="o">.</span><span class="n">vsignatures</span><span class="p">(</span><span class="n">approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span>
                                         <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">):</span>
                
                <span class="c1"># create vibronic state with a given signature</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">VibronicState</span><span class="p">(</span><span class="n">es1</span><span class="p">,</span> <span class="n">vsig1</span><span class="p">)</span>
                                        
                <span class="k">if</span> <span class="n">save_indices</span><span class="p">:</span>
                    <span class="c1"># save indices corresponding to vibrational sublevels</span>
                    <span class="c1"># of a given electronic state</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">ist</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vibsigs</span><span class="p">[</span><span class="n">ast</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ess1</span><span class="p">,</span> <span class="n">vsig1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">ast</span><span class="p">]</span> <span class="o">=</span> <span class="n">ist</span>
    
                <span class="k">yield</span> <span class="n">ast</span> <span class="p">,</span><span class="n">s1</span>
                
                <span class="n">ast</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># count all states</span>
                <span class="n">nsig</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># count the number of vibrational signatures    </span>
            
            <span class="c1"># if no vibrational signatures</span>
            <span class="k">if</span> <span class="n">nsig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  
                <span class="c1"># if True return vibronic states even </span>
                <span class="c1"># for purely electronic state</span>
                <span class="k">if</span> <span class="n">all_vibronic</span><span class="p">:</span>
                    <span class="n">s1</span> <span class="o">=</span> <span class="n">VibronicState</span><span class="p">(</span><span class="n">es1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s1</span> <span class="o">=</span> <span class="n">es1</span>

            <span class="k">if</span> <span class="n">save_indices</span><span class="p">:</span>
                <span class="c1"># save electronic signatures to be searchable later</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elsigs</span><span class="p">[</span><span class="n">ist</span><span class="p">]</span> <span class="o">=</span> <span class="n">ess1</span>
                <span class="c1"># save the band to which this electronic index corresponds</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">ist</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ess1</span><span class="p">)</span>
            
            <span class="n">ist</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># count electronic states</span></div>
            

<div class="viewcode-block" id="AggregateBase.elstates"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.elstates">[docs]</a>    <span class="k">def</span> <span class="nf">elstates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;LQ&quot;</span><span class="p">,</span> <span class="n">save_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generator of electronic states </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ess1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elsignatures</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">):</span>
            <span class="n">es1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ElectronicState</span><span class="p">(</span><span class="n">ess1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">a</span><span class="p">,</span><span class="n">es1</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span></div>
        

    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span>  <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">quantarhei.Aggregate object&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">===========================&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">name = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">number of molecules = </span><span class="si">%i</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Monomer </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">count</span> 
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Resonance coupling matrix: &quot;</span>
        <span class="n">out</span> <span class="o">+=</span>   <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------------------------- &quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resonance_coupling</span><span class="p">)</span>
            
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Aggregate built = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Selected attributes&quot;</span>
        <span class="n">out</span> <span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--------------------&quot;</span>
        <span class="n">out</span> <span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">mult = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nel  = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Ntot = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">)</span>
        
        
        <span class="k">return</span> <span class="n">out</span>


    <span class="c1">###########################################################################</span>
    <span class="c1">#</span>
    <span class="c1">#    BUILDING</span>
    <span class="c1">#</span>
    <span class="c1">###########################################################################</span>
        
<div class="viewcode-block" id="AggregateBase.build"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sbi_for_higher_ex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">vibgen_approx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds aggregate properties</span>
<span class="sd">        </span>
<span class="sd">        Calculates Hamiltonian and transition dipole moment matrices and</span>
<span class="sd">        sets up system-bath interaction </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        mult : int</span>
<span class="sd">            exciton multiplicity</span>
<span class="sd">            </span>
<span class="sd">        sbi_for_higher_ex: bool</span>
<span class="sd">            If set True, system-bath information is explicitely created for</span>
<span class="sd">            higher exciton states (consistent with the specified parameters</span>
<span class="sd">            `mult`). If set False, it is expected that if system-bath</span>
<span class="sd">            interaction for higher excitons is needed, it will be reconstructed</span>
<span class="sd">            from the single exciton part of this object</span>
<span class="sd">            </span>
<span class="sd">        vibge_approx: </span>
<span class="sd">            Approximation used in the generation of vibrational state.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
        <span class="n">manager</span><span class="o">.</span><span class="n">set_current_units</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>
        
        <span class="c1"># maximum multiplicity of excitons handled by this aggregate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mult</span> <span class="o">=</span> <span class="n">mult</span> 
        <span class="k">if</span> <span class="n">sbi_for_higher_ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sbi_mult</span> <span class="o">=</span> <span class="n">mult</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sbi_mult</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1">#######################################################################</span>
        <span class="c1">#</span>
        <span class="c1"># Electronic and vibrational states</span>
        <span class="c1">#</span>
        <span class="c1">#######################################################################</span>
        
        <span class="c1"># total number of electronic states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_number_of_electronic_states</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">)</span>
        
        <span class="c1"># storage for indices of vibrational states </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># there are as many lists of indices as there are electronic states</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        
        <span class="c1"># number of states in the aggregate (taking into account </span>
        <span class="c1"># approximations in generation of vibrational states)</span>
        <span class="n">Ntot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_number_of_states</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> 
                                           <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span>
                                           <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span> <span class="n">save_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                           <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">)</span>
        <span class="c1"># save total number of states (including vibrational)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span> <span class="o">=</span> <span class="n">Ntot</span>
        <span class="c1"># information about the band to which a state belongs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># electronic signature for every state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elsigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span>
        <span class="c1"># vibrational signature for each state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vibsigs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span>
        <span class="c1"># FIXME: what is this???</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># Hamiltonian matrix        </span>
        <span class="n">HH</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">Ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Transition dipole moment matrix</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">Ntot</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Matrix of Franck-Condon factors</span>
        <span class="n">FC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">Ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Matrix of the transition widths (their square roots)</span>
        <span class="n">Wd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">Ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
        <span class="c1"># Matrix of dephasing rates</span>
        <span class="n">Dr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">Ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
        
        <span class="c1"># electronic indices if twice excited state (zero for all other states)</span>
        <span class="n">twoex_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        
        <span class="c1"># Initialization of the matrix of couplings between states</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_initiated</span><span class="p">:</span>    
            <span class="bp">self</span><span class="o">.</span><span class="n">init_coupling_matrix</span><span class="p">()</span>            

        <span class="n">Ntot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_number_of_states</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> 
                                           <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span>
                                           <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span> <span class="n">save_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                           <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">)</span>
        
        <span class="c1">#print(self.which_band, self.Ntot, len(self.which_band))</span>
            
        <span class="c1"># Set up Hamiltonian and Transition dipole moment matrices</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allstates</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> 
                                    <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span>
                                    <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s0</span> <span class="o">=</span> <span class="n">s1</span>

            <span class="c1"># diagonal Hamiltonian elements</span>
            <span class="n">HH</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">energy</span><span class="p">()</span>
            
            <span class="c1"># get dephasing and width from the ground-state </span>
            <span class="c1"># for each excited state</span>
            <span class="n">elind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">Wd</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transition_width</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s0</span><span class="p">))</span>
                <span class="n">Dr</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transition_dephasing</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s0</span><span class="p">))</span>

            <span class="c1"># save composition of twice excited states</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">elind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># k_s counts excited molecules in the doubly exc. state</span>
                <span class="c1"># there are molecules 0 and 1 in diad (n,m)</span>
                <span class="n">k_s</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># counts positons in the electronic signature</span>
                <span class="c1"># i.e. it counts molecular index</span>
                <span class="n">sig_position</span> <span class="o">=</span> <span class="mi">0</span> 
                <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">s1</span><span class="o">.</span><span class="n">elstate</span><span class="o">.</span><span class="n">elsignature</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i_s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># we save indices of electronic states and </span>
                        <span class="c1"># 0 is taken by the ground state</span>
                        <span class="n">twoex_indx</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">k_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_position</span> <span class="o">+</span> <span class="mi">1</span> 
                        <span class="n">k_s</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">sig_position</span> <span class="o">+=</span> <span class="mi">1</span>    

                
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allstates</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">,</span> 
                                    <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span>
                                    <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">):</span> 
            
                <span class="n">DD</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_dipole</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>                
                <span class="n">FC</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_factor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">HH</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> 
        
        <span class="c1"># Storing Hamiltonian and dipole moment matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HH</span> <span class="o">=</span> <span class="n">HH</span>
        <span class="c1"># FIXME: Do I need this???</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HamOp</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">HH</span><span class="p">)</span>
        <span class="c1"># dipole moments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DD</span> <span class="o">=</span> <span class="n">DD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TrDMOp</span> <span class="o">=</span> <span class="n">TransitionDipoleMoment</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">DD</span><span class="p">)</span> 
        <span class="c1"># Franck-Condon factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span> <span class="o">=</span> <span class="n">FC</span>
        <span class="c1"># widths </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span> <span class="o">=</span> <span class="n">Wd</span>
        <span class="c1"># dephasings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dr</span> <span class="o">=</span> <span class="n">Dr</span>
        
        <span class="c1"># composition of two-ex states</span>
        <span class="c1"># first index of state a is twoex_indx[0, a]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span> <span class="o">=</span> <span class="n">twoex_indx</span>
        
        <span class="c1"># squares of transition dipoles</span>
        <span class="n">dd2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span> <span class="n">Ntot</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ntot</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ntot</span><span class="p">):</span>
                <span class="n">dd2</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,:],</span><span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D2</span> <span class="o">=</span> <span class="n">dd2</span>
        <span class="c1"># FIXME: do I need this??? Is it even corrrect??? (maybe amax?)</span>
        <span class="c1"># maximum of transition dipole moment elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D2_max</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dd2</span><span class="p">)</span>
    
        <span class="c1"># Number of states in individual bands      </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_states_in_band</span><span class="p">(</span><span class="n">band</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span>
            <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span> 
            <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">)</span>

        <span class="c1"># Number of electronic states in individual bands      </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nbe</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nbe</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_electronic_states_in_band</span><span class="p">(</span><span class="n">band</span><span class="o">=</span><span class="n">ii</span><span class="p">)</span>
       
        
        <span class="c1">#######################################################################</span>
        <span class="c1">#</span>
        <span class="c1"># System-bath interaction</span>
        <span class="c1">#</span>
        <span class="c1">#######################################################################</span>
 
        <span class="c1">#</span>
        <span class="c1">#  There are two methods to set system-bath interaction</span>
        <span class="c1">#      1) Each molecule gets its bath correlation function</span>
        <span class="c1">#      2) Global energy gap correlation function matrix is set</span>
        <span class="c1">#</span>
        
        <span class="c1"># is energy gap correlation function matrix present?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_egcf_matrix</span><span class="p">:</span>
            
            <span class="c1"># Check the consistency of the energy gap correlation matrix</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span><span class="o">.</span><span class="n">nob</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Correlation matrix has a size different&quot;</span> <span class="o">+</span> 
                                <span class="s2">&quot; from the number of monomers&quot;</span><span class="p">)</span>
            <span class="c1">#FIXME The aggregate having a egcf matrix does not mean the monomers</span>
            <span class="c1">#have egcf matrices. They could just have correlation funtions.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_is_mapped_on_egcf_matrix</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">egcf_matrix</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Correlation matrix in the monomer&quot;</span> <span class="o">+</span>
                                    <span class="s2">&quot; has to be the same as the one of&quot;</span> <span class="o">+</span>
                                    <span class="s2">&quot; the aggregate.&quot;</span><span class="p">)</span>
            <span class="c1"># seems like everything is consistent -&gt; we can calculate system-</span>
            <span class="c1"># -bath interaction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span> <span class="o">=</span> <span class="kc">True</span>   
                     
        <span class="c1"># if not, try to get one from monomers later</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="c1"># try to set energy gap correlation matrix from monomers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span><span class="p">:</span>   
            
            <span class="c1"># let&#39;s assume we can calculate EGCF matrix from monomers</span>
            <span class="n">egcf_ok</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="c1"># get correlation function from a monomer</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">egcf1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_transition_environment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># we cannot calculate EGCF matrix, there is no system-bath</span>
                <span class="c1"># interaction, or it is not based on correlation functions</span>
                <span class="n">egcf_ok</span> <span class="o">=</span> <span class="kc">False</span> 
            
            <span class="c1"># if we have correlation functions for nonomers, let&#39;s construct</span>
            <span class="c1"># the EGCF matrix</span>
            <span class="k">if</span> <span class="n">egcf_ok</span><span class="p">:</span>
                <span class="c1"># time axis of the first monomer</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">egcf1</span><span class="o">.</span><span class="n">axis</span>  
                <span class="c1"># Number of correlation functions is the number of electronic</span>
                <span class="c1"># states minus ground state (this assumes that only electronic</span>
                <span class="c1"># states are coupled to the bath)</span>
                <span class="n">Nelg</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># ASSUMPTION: here we assume a single electronic </span>
                          <span class="c1"># ground state         </span>
                <span class="k">if</span> <span class="n">sbi_for_higher_ex</span><span class="p">:</span>
                    <span class="c1"># except for ground state, all electronic states have EGCF</span>
                    <span class="n">Ncf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span> <span class="o">-</span> <span class="n">Nelg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># in single exciton, two-level molecule picture, there is</span>
                    <span class="c1"># a single correlation function per monomer</span>
                    <span class="c1"># ASSUMPTION: Two-level molecules</span>
                    <span class="n">Ncf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span>
                    
                <span class="c1"># instantiate the EGCF matrix object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span> <span class="o">=</span> <span class="n">CorrelationFunctionMatrix</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Ncf</span><span class="p">)</span>
                
                <span class="c1"># run over all electronic states</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                    
                    <span class="c1"># in single exciton band</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">Nelg</span>
                        <span class="n">mon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="c1"># get correlation for a monomer</span>
                        <span class="c1"># ASSUMPTION: Two-level molecule</span>
                        <span class="n">cfce</span> <span class="o">=</span> <span class="n">mon</span><span class="o">.</span><span class="n">get_transition_environment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># set correlation function into the diagonal of the</span>
                        <span class="c1"># EGCF matrix. Index corresponds to the monomer</span>
                        <span class="n">mapi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span><span class="o">.</span><span class="n">set_correlation_function</span><span class="p">(</span><span class="n">cfce</span><span class="p">,</span>
                                                                     <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span>
                        <span class="c1"># FIXME: what is returned?</span>
                        <span class="k">if</span> <span class="n">mapi</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something&#39;s wrong&quot;</span><span class="p">)</span>
                                                
                    <span class="c1"># in two-exciton band</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sbi_for_higher_ex</span><span class="p">:</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">Nelg</span>
                        <span class="c1"># monomers of a two-exciton state are obtaines</span>
                        <span class="c1"># FIXME: is this correct???</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elsigs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elsigs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">mon1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">mon2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="c1"># we get correlation functions of the two monomers</span>
                        <span class="c1"># ASSUMPTION: Two-level molecules</span>
                        <span class="n">cfce1</span> <span class="o">=</span> <span class="n">mon1</span><span class="o">.</span><span class="n">get_transition_environment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
                        <span class="n">cfce2</span> <span class="o">=</span> <span class="n">mon2</span><span class="o">.</span><span class="n">get_transition_environment</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># correlation functions are added to form a two-exciton</span>
                        <span class="c1"># correlation function</span>
                        <span class="n">cfce</span> <span class="o">=</span> <span class="n">cfce1</span> <span class="o">+</span> <span class="n">cfce2</span>
                        <span class="c1"># Two-exciton correlation function is set into</span>
                        <span class="c1"># EGCF matrix</span>
                        <span class="n">mapi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span><span class="o">.</span><span class="n">set_correlation_function</span><span class="p">(</span><span class="n">cfce</span><span class="p">,</span>
                                                                     <span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">l</span><span class="p">)])</span>
                        
                        <span class="c1"># FIXME: cross-correlation between double excitons</span>
                        <span class="c1"># needs to be handled.</span>
                    
                        <span class="k">if</span> <span class="n">mapi</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something&#39;s wrong&quot;</span><span class="p">)</span>

                    <span class="c1"># some effective theory here</span>
                    <span class="c1"># FIXME: make sure we know what the ``sbi_for_higher_ex``</span>
                    <span class="c1">#        switch actually means</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sbi_for_higher_ex</span><span class="p">):</span>
                        <span class="c1"># this should be handled by</span>
                        <span class="c1"># a map between double excitons and site cor. functions</span>
                        <span class="k">pass</span>
                    
                    <span class="c1"># no theory for higher bands so-far</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sbi_for_higher_ex</span><span class="p">:</span>
                        <span class="k">pass</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_egcf_matrix</span> <span class="o">=</span> <span class="kc">True</span>   

        <span class="c1"># if all needed for system-bath interaction is present</span>
        <span class="c1"># we can construct the SystemBathInteraction object</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_system_bath_interaction</span><span class="p">:</span>
            
            <span class="c1"># system interaction operators</span>
            <span class="n">iops</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># how many operators should be created</span>
            <span class="k">if</span> <span class="n">sbi_for_higher_ex</span><span class="p">:</span>
                <span class="n">Nop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># all electronic states</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Nop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nbe</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># we count only single excited states</span>

            <span class="c1"># if there are more states in the single exciton block</span>
            <span class="c1"># than the number of sites, it means we have vibrational states</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmono</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># create a projection operator for each monomer</span>
                <span class="c1"># a monomer corresponds to one single excited state starting</span>
                <span class="c1"># with electronic index 1 (0 is the ground state)</span>
                <span class="c1"># ASSUMPTION: Two-level molecules </span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nop</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> 
                    <span class="n">op1</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># here we make a projector on a given electronic state |i&gt;</span>
                    <span class="c1"># ASSUMPTION: Oscillator is represented by its eigenstates</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">op1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">iops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>      
                  
            <span class="c1"># standard case with only electronic states</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># create a projection operator for each monomer</span>
                <span class="c1"># a monomer corresponds to one single excited state starting</span>
                <span class="c1"># with electronic index 1 (0 is the ground state)</span>
                <span class="c1"># ASSUMPTION: Two-level molecules </span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nop</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> 
                    <span class="n">op1</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">op1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">iops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
                
            <span class="c1"># we create SystemBathInteraction object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">SystemBathInteraction</span><span class="p">(</span><span class="n">iops</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">egcf_matrix</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>  
                                                 
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># system-bath interaction is not present</span>
            <span class="k">pass</span> 
            
        <span class="bp">self</span><span class="o">.</span><span class="n">_built</span> <span class="o">=</span> <span class="kc">True</span>
    
        <span class="n">manager</span><span class="o">.</span><span class="n">unset_current_units</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="AggregateBase.rebuild"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.rebuild">[docs]</a>    <span class="k">def</span> <span class="nf">rebuild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sbi_for_higher_ex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">vibgen_approx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cleans the object and rebuilds it</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="n">mult</span><span class="p">,</span> <span class="n">sbi_for_higher_ex</span><span class="o">=</span><span class="n">sbi_for_higher_ex</span><span class="p">,</span>
              <span class="n">vibgen_approx</span><span class="o">=</span><span class="n">vibgen_approx</span><span class="p">,</span> <span class="n">Nvib</span><span class="o">=</span><span class="n">Nvib</span><span class="p">,</span>
              <span class="n">vibenergy_cutoff</span><span class="o">=</span><span class="n">vibenergy_cutoff</span><span class="p">)</span></div>
        
        
    
    <span class="c1">###########################################################################</span>
    <span class="c1">#</span>
    <span class="c1">#    POST BUILDING METHODS</span>
    <span class="c1">#</span>
    <span class="c1">########################################################################### </span>

<div class="viewcode-block" id="AggregateBase.trace_over_vibrations"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.trace_over_vibrations">[docs]</a>    <span class="k">def</span> <span class="nf">trace_over_vibrations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Average operator over vibrational degrees of freedom</span>
<span class="sd">        </span>
<span class="sd">        Average MUST be done in site basis. Only in site basis</span>
<span class="sd">        we can distinguish the vibrational states properly</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_indices</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">evolution</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">whole</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">ReducedDensityMatrix</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">DensityMatrix</span><span class="p">):</span>
                
                <span class="n">nop</span> <span class="o">=</span> <span class="n">ReducedDensityMatrix</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">)</span>
                
                
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">ReducedDensityMatrixEvolution</span><span class="p">):</span>
                
                <span class="k">if</span> <span class="n">Nt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nop</span> <span class="o">=</span> <span class="n">ReducedDensityMatrix</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">)</span>
                    <span class="n">evolution</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">whole</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nop</span> <span class="o">=</span> <span class="n">ReducedDensityMatrixEvolution</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">TimeAxis</span><span class="p">)</span>
                    <span class="n">rhoi</span> <span class="o">=</span> <span class="n">ReducedDensityMatrix</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">)</span>
                    <span class="c1"># we set zero initial condition, because this initialized </span>
                    <span class="c1"># the data storage</span>
                    <span class="n">nop</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">rhoi</span><span class="p">)</span>
                    <span class="n">evolution</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">whole</span> <span class="o">=</span> <span class="kc">True</span>
                                    
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Operation not implemented for this type: &quot;</span><span class="o">+</span>
                                <span class="n">operator</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">n_indices</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                
                <span class="c1"># convert to representation by ground-state oscillator</span>
                
                <span class="c1"># FIXME: This limitation might not be necessary</span>
                <span class="c1"># in the ground states of all monomers, there must be the same</span>
                <span class="c1"># or greater number of levels than in the excited state</span>
                
                <span class="c1"># over all monomers</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmono</span><span class="p">):</span>
                    <span class="n">mono</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="c1"># over all modes</span>
                    <span class="n">n_mod</span> <span class="o">=</span> <span class="n">mono</span><span class="o">.</span><span class="n">get_number_of_modes</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mod</span><span class="p">):</span>
                        <span class="n">mod</span> <span class="o">=</span> <span class="n">mono</span><span class="o">.</span><span class="n">get_Mode</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">n_g</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">get_nmax</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="c1"># over all excited states</span>
                        <span class="c1"># FIXME: this should be mono.Nel as in Aggregate</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mono</span><span class="o">.</span><span class="n">nel</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="n">n_e</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">get_nmax</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">n_e</span> <span class="o">&gt;</span> <span class="n">n_g</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of levels&quot;</span><span class="o">+</span>
                        <span class="s2">&quot; in the excited state of a molecule has to be </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
                        <span class="s2">&quot;the same or smaller than in the ground state&quot;</span><span class="p">)</span>
                        
                
                <span class="c1"># do the conversion</span>
                
                <span class="c1"># </span>
                <span class="c1"># ground state vibrational states</span>
                <span class="c1">#</span>
                <span class="n">stgs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i_g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">vs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibsigs</span><span class="p">[</span><span class="n">i_g</span><span class="p">]</span>
                    <span class="n">stg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_VibronicState</span><span class="p">(</span><span class="n">vs_g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                <span class="n">vs_g</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">stgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stg</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="n">evolution</span><span class="p">:</span>
                    
                    <span class="k">if</span> <span class="n">whole</span><span class="p">:</span>
                        <span class="c1">#import time</span>
                        
                        <span class="c1">#t1 = time.time()</span>
                        <span class="c1"># loop over electronic states n, m</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i_n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                                
                                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                                    <span class="k">for</span> <span class="n">i_m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>

                                        <span class="k">for</span> <span class="n">i_g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                            
                                            
                                            <span class="n">fc_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span><span class="p">[</span><span class="n">i_g</span><span class="p">,</span> <span class="n">i_n</span><span class="p">]</span>
                                            <span class="n">fc_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span><span class="p">[</span><span class="n">i_m</span><span class="p">,</span> <span class="n">i_g</span><span class="p">]</span>
                                            
                                            <span class="n">prod</span> <span class="o">=</span> <span class="n">fc_n</span><span class="o">*</span><span class="n">fc_m</span>
                                            
                                            <span class="n">nop</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">+=</span> \
                                            <span class="n">operator</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">i_n</span><span class="p">,</span> <span class="n">i_m</span><span class="p">]</span><span class="o">*</span><span class="n">prod</span>
                                            
                        <span class="c1">#t2 = time.time(</span>
                        <span class="c1">#print(&quot;TIME: &quot;, t2-t1)</span>
                        
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># loop over electronic states n, m</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i_n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                                
                                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                                    <span class="k">for</span> <span class="n">i_m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                                        
                                        <span class="k">for</span> <span class="n">i_g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                            
                                             
                                            <span class="n">fc_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span><span class="p">[</span><span class="n">i_g</span><span class="p">,</span> <span class="n">i_n</span><span class="p">]</span>
                                            <span class="n">fc_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span><span class="p">[</span><span class="n">i_m</span><span class="p">,</span> <span class="n">i_g</span><span class="p">]</span>
                                            
                                            <span class="n">contrib</span> <span class="o">=</span> \
                                              <span class="n">operator</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">Nt</span><span class="p">,</span> <span class="n">i_n</span><span class="p">,</span> <span class="n">i_m</span><span class="p">]</span>\
                                              <span class="o">*</span><span class="n">fc_n</span><span class="o">*</span><span class="n">fc_m</span>
                                            <span class="n">nop</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">contrib</span>                    
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># loop over electronic states n, m</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i_n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                            
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">i_m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                                    
                                    <span class="k">for</span> <span class="n">i_g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                                                                    
                                        <span class="n">fc_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span><span class="p">[</span><span class="n">i_g</span><span class="p">,</span> <span class="n">i_n</span><span class="p">]</span>
                                        <span class="n">fc_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FCf</span><span class="p">[</span><span class="n">i_m</span><span class="p">,</span> <span class="n">i_g</span><span class="p">]</span>
                                        
                                        <span class="n">contrib</span> <span class="o">=</span> \
                                        <span class="n">operator</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i_n</span><span class="p">,</span> <span class="n">i_m</span><span class="p">]</span><span class="o">*</span><span class="n">fc_n</span><span class="o">*</span><span class="n">fc_m</span>
                                        <span class="n">nop</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">contrib</span>
                                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot trace over this object: &quot;</span><span class="o">+</span>
                                <span class="s2">&quot;wrong number of indices&quot;</span><span class="p">)</span>
                            
            <span class="k">return</span> <span class="n">nop</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Incompatible operator&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="AggregateBase.get_RWA_suggestion"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_RWA_suggestion">[docs]</a>    <span class="k">def</span> <span class="nf">get_RWA_suggestion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns average transition energy </span>
<span class="sd">        </span>
<span class="sd">        Average transition energy of the monomer as a suggestion for </span>
<span class="sd">        RWA frequency</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">Nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># number of monomers</span>
        <span class="n">esum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nn</span><span class="p">):</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
            <span class="n">omeg</span> <span class="o">=</span> <span class="n">mn</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">mn</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">esum</span> <span class="o">+=</span> <span class="n">omeg</span>

        <span class="k">return</span> <span class="n">esum</span><span class="o">/</span><span class="n">Nn</span></div>
        
    
<div class="viewcode-block" id="AggregateBase.get_RelaxationTensor"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_RelaxationTensor">[docs]</a>    <span class="k">def</span> <span class="nf">get_RelaxationTensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeaxis</span><span class="p">,</span>
                       <span class="n">relaxation_theory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">time_dependent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">secular_relaxation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">relaxation_cutoff_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">coupling_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">recalculate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">as_operators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a relaxation tensor corresponding to the aggregate</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        timeaxis : TimeAxis</span>
<span class="sd">            Time axis of the relaxation tensor calculation. It has to be </span>
<span class="sd">            compatible with the time axis of the correlation functions</span>
<span class="sd">            </span>
<span class="sd">        relaxation_theory: str</span>
<span class="sd">            One of the available relaxation theories</span>
<span class="sd">            </span>
<span class="sd">        time_dependent : boolean</span>
<span class="sd">            Should the relaxation tensor time dependent?</span>
<span class="sd">            </span>
<span class="sd">        secular_relaxation :</span>
<span class="sd">            Should the tensor be secular?</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        RR : RelaxationTensor</span>
<span class="sd">            Relaxation tensor of the aggregate</span>
<span class="sd">            </span>
<span class="sd">        ham : Hamiltonian</span>
<span class="sd">            Hamiltonian corresponding to the aggregate, renormalized by</span>
<span class="sd">            the system-bath interaction</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">RedfieldRelaxationTensor</span>
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">TDRedfieldRelaxationTensor</span>
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">FoersterRelaxationTensor</span>
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">TDFoersterRelaxationTensor</span>
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">RedfieldFoersterRelaxationTensor</span>
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">TDRedfieldFoersterRelaxationTensor</span>
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">LindbladForm</span>
        
        <span class="kn">from</span> <span class="nn">..core.managers</span> <span class="k">import</span> <span class="n">eigenbasis_of</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="n">ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Hamiltonian</span><span class="p">()</span>
            <span class="n">sbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SystemBathInteraction</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
        
        <span class="c1">#</span>
        <span class="c1"># Dictionary of available theories</span>
        <span class="c1">#</span>
        <span class="n">theories</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;standard_Redfield&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;standard_Redfield&quot;</span><span class="p">,</span><span class="s2">&quot;stR&quot;</span><span class="p">,</span><span class="s2">&quot;Redfield&quot;</span><span class="p">,</span>
                                         <span class="s2">&quot;CLME2&quot;</span><span class="p">,</span><span class="s2">&quot;QME&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;standard_Foerster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;standard_Foerster&quot;</span><span class="p">,</span><span class="s2">&quot;stF&quot;</span><span class="p">,</span><span class="s2">&quot;Foerster&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;combined_RedfieldFoerster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;combined_RedfieldFoerster&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;cRF&quot;</span><span class="p">,</span><span class="s2">&quot;Redfield-Foerster&quot;</span><span class="p">]</span>
        <span class="c1">#</span>
        <span class="c1"># Future</span>
        <span class="c1">#</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;modified_Redfield&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;modifield_Redfield&quot;</span><span class="p">,</span> <span class="s2">&quot;mR&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;noneq_modified_Redfield&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;noneq_modified_Redfield&quot;</span><span class="p">,</span> 
                                               <span class="s2">&quot;nemR&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;generalized_Foerster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;generalized_Foerster&quot;</span><span class="p">,</span> <span class="s2">&quot;gF&quot;</span><span class="p">,</span> 
                                            <span class="s2">&quot;multichromophoric_Foerster&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;noneq_Foerster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;noneq_Foerster&quot;</span><span class="p">,</span> <span class="s2">&quot;neF&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;combined_WeakStrong&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;combined_WeakStrong&quot;</span><span class="p">,</span> <span class="s2">&quot;cWS&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;Lindblad_form&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Lindblad_form&quot;</span><span class="p">,</span> <span class="s2">&quot;Lf&quot;</span><span class="p">]</span>
        <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;electronic_Lindblad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;electronic_Lindblad&quot;</span><span class="p">,</span> <span class="s2">&quot;eLf&quot;</span><span class="p">]</span>

        <span class="c1">#if ((not recalculate) and </span>
        <span class="c1">#    (relaxation_theory in theories[self._relaxation_theory])):</span>
        <span class="c1">#    return self.RelaxationTensor, self.RelaxationHamiltonian</span>
            
        
        <span class="k">if</span> <span class="n">relaxation_theory</span> <span class="ow">in</span> <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;standard_Redfield&quot;</span><span class="p">]:</span>
            
            <span class="k">if</span> <span class="n">time_dependent</span><span class="p">:</span>
                
                <span class="c1"># Time dependent standard Refield</span>
            
                <span class="n">ham</span><span class="o">.</span><span class="n">protect_basis</span><span class="p">()</span>
                <span class="k">with</span> <span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">ham</span><span class="p">):</span>
                    <span class="n">relaxT</span> <span class="o">=</span> <span class="n">TDRedfieldRelaxationTensor</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">,</span> 
                                        <span class="n">cutoff_time</span><span class="o">=</span><span class="n">relaxation_cutoff_time</span><span class="p">,</span>
                                        <span class="n">as_operators</span><span class="o">=</span><span class="n">as_operators</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">secular_relaxation</span><span class="p">:</span>
                        <span class="n">relaxT</span><span class="o">.</span><span class="n">secularize</span><span class="p">()</span> 
                <span class="n">ham</span><span class="o">.</span><span class="n">unprotect_basis</span><span class="p">()</span>                        
                                                
            <span class="k">else</span><span class="p">:</span>
            
                <span class="c1"># Time independent standard Refield</span>
            
                
                <span class="n">ham</span><span class="o">.</span><span class="n">protect_basis</span><span class="p">()</span>
                
                <span class="k">with</span> <span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">ham</span><span class="p">):</span>
                    <span class="n">relaxT</span> <span class="o">=</span> <span class="n">RedfieldRelaxationTensor</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">,</span>
                                                    <span class="n">as_operators</span><span class="o">=</span><span class="n">as_operators</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">secular_relaxation</span><span class="p">:</span>
                        <span class="n">relaxT</span><span class="o">.</span><span class="n">secularize</span><span class="p">()</span>
                    
                <span class="n">ham</span><span class="o">.</span><span class="n">unprotect_basis</span><span class="p">()</span>  

                
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationTensor</span> <span class="o">=</span> <span class="n">relaxT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationHamiltonian</span> <span class="o">=</span> <span class="n">ham</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_relaxation_tensor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relaxation_theory</span> <span class="o">=</span> <span class="s2">&quot;standard_Redfield&quot;</span>
                
            <span class="k">return</span> <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham</span>
            
        <span class="k">elif</span> <span class="n">relaxation_theory</span> <span class="ow">in</span> <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;standard_Foerster&quot;</span><span class="p">]:</span>
            
            <span class="k">if</span> <span class="n">time_dependent</span><span class="p">:</span>
                
                <span class="c1"># Time dependent standard Foerster               </span>
                <span class="n">relaxT</span> <span class="o">=</span> <span class="n">TDFoersterRelaxationTensor</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">)</span>
                <span class="n">dat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span><span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">dat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ham</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ham_0</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dat</span><span class="p">)</span>
          
            <span class="k">else</span><span class="p">:</span>
            
                <span class="c1"># Time independent standard Foerster</span>
            
                <span class="c1">#</span>
                <span class="c1"># This is done strictly in site basis</span>
                <span class="c1">#</span>
            
                <span class="n">relaxT</span> <span class="o">=</span> <span class="n">FoersterRelaxationTensor</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">)</span>
                <span class="n">dat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span><span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">dat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ham</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ham_0</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dat</span><span class="p">)</span>
                
            <span class="c1"># The Hamiltonian for propagation is the one without </span>
            <span class="c1"># resonance coupling         </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationTensor</span> <span class="o">=</span> <span class="n">relaxT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationHamiltonian</span> <span class="o">=</span> <span class="n">ham_0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_relaxation_tensor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relaxation_theory</span> <span class="o">=</span> <span class="s2">&quot;standard_Foerster&quot;</span>
            
            <span class="k">return</span> <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham_0</span>
                
        <span class="k">elif</span> <span class="n">relaxation_theory</span> <span class="ow">in</span> <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;combined_RedfieldFoerster&quot;</span><span class="p">]:</span>
            
            <span class="k">if</span> <span class="n">time_dependent</span><span class="p">:</span>
                
                <span class="c1"># Time dependent combined tensor</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">subtract_cutoff_coupling</span><span class="p">(</span><span class="n">coupling_cutoff</span><span class="p">)</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">protect_basis</span><span class="p">()</span>
                <span class="k">with</span> <span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">ham</span><span class="p">):</span>
                    <span class="n">relaxT</span> <span class="o">=</span> \
                             <span class="n">TDRedfieldFoersterRelaxationTensor</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">,</span>
                                            <span class="n">coupling_cutoff</span><span class="o">=</span><span class="n">coupling_cutoff</span><span class="p">,</span>
                                            <span class="n">cutoff_time</span><span class="o">=</span><span class="n">relaxation_cutoff_time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">secular_relaxation</span><span class="p">:</span>
                        <span class="n">relaxT</span><span class="o">.</span><span class="n">secularize</span><span class="p">()</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">unprotect_basis</span><span class="p">()</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">recover_cutoff_coupling</span><span class="p">()</span>                        
                        
            <span class="k">else</span><span class="p">:</span>
            
                <span class="c1"># Time independent combined tensor           </span>
                <span class="n">ham</span><span class="o">.</span><span class="n">subtract_cutoff_coupling</span><span class="p">(</span><span class="n">coupling_cutoff</span><span class="p">)</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">protect_basis</span><span class="p">()</span>
                <span class="k">with</span> <span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">ham</span><span class="p">):</span>
                    <span class="n">relaxT</span> <span class="o">=</span> \
                             <span class="n">RedfieldFoersterRelaxationTensor</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">,</span>
                                            <span class="n">coupling_cutoff</span><span class="o">=</span><span class="n">coupling_cutoff</span><span class="p">,</span>
                                            <span class="n">cutoff_time</span><span class="o">=</span><span class="n">relaxation_cutoff_time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">secular_relaxation</span><span class="p">:</span>
                        <span class="n">relaxT</span><span class="o">.</span><span class="n">secularize</span><span class="p">()</span>

                    <span class="c1">#print(&quot;Last line of the context&quot;, Manager().get_current_basis())</span>
                <span class="c1">#print(&quot;Left context&quot;, Manager().get_current_basis())</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">unprotect_basis</span><span class="p">()</span>
                <span class="n">ham</span><span class="o">.</span><span class="n">recover_cutoff_coupling</span><span class="p">()</span>

            <span class="c1">#</span>
            <span class="c1"># create a corresponding propagator</span>
            <span class="c1">#</span>
            <span class="n">ham1</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ham</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">ham1</span><span class="o">.</span><span class="n">subtract_cutoff_coupling</span><span class="p">(</span><span class="n">coupling_cutoff</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationTensor</span> <span class="o">=</span> <span class="n">relaxT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationHamiltonian</span> <span class="o">=</span> <span class="n">ham1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_relaxation_tensor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relaxation_theory</span> <span class="o">=</span> <span class="s2">&quot;combined_RedfieldFoerster&quot;</span>
            
            <span class="k">return</span> <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham1</span>       
            
        <span class="k">elif</span> <span class="n">relaxation_theory</span> <span class="ow">in</span> <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;combined_WeakStrong&quot;</span><span class="p">]:</span> 
            
            <span class="k">pass</span>
 
        <span class="k">elif</span> <span class="n">relaxation_theory</span> <span class="ow">in</span> <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;Lindblad_form&quot;</span><span class="p">]:</span>
            
            <span class="k">if</span> <span class="n">time_dependent</span><span class="p">:</span>
                
                <span class="c1"># Time dependent standard Refield</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Time dependent Lindblad not implemented yet&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
            
                <span class="c1"># Linblad form</span>
            
                <span class="c1">#ham.protect_basis()</span>
                <span class="c1">#with eigenbasis_of(ham):</span>
                <span class="n">relaxT</span> <span class="o">=</span> <span class="n">LindbladForm</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">secular_relaxation</span><span class="p">:</span>
                    <span class="n">relaxT</span><span class="o">.</span><span class="n">convert_2_tensor</span><span class="p">()</span>
                    <span class="n">relaxT</span><span class="o">.</span><span class="n">secularize</span><span class="p">()</span>
                <span class="c1">#ham.unprotect_basis()  </span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationTensor</span> <span class="o">=</span> <span class="n">relaxT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationHamiltonian</span> <span class="o">=</span> <span class="n">ham</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_relaxation_tensor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relaxation_theory</span> <span class="o">=</span> <span class="s2">&quot;Lindblad_form&quot;</span>
                
            <span class="k">return</span> <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham</span>
 
        <span class="k">elif</span> <span class="n">relaxation_theory</span> <span class="ow">in</span> <span class="n">theories</span><span class="p">[</span><span class="s2">&quot;electronic_Lindblad&quot;</span><span class="p">]:</span>
            
            <span class="k">if</span> <span class="n">time_dependent</span><span class="p">:</span>
                
                <span class="c1"># Time dependent standard Refield</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Time dependent Lindblad not implemented yet&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
            
                <span class="c1"># For purely electronic system, calculate normal Lindblad form</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">:</span>
                    <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_RelaxationTensor</span><span class="p">(</span><span class="n">timeaxis</span><span class="p">,</span> 
                                <span class="n">relaxation_theory</span><span class="o">=</span><span class="s2">&quot;Lindblad_form&quot;</span><span class="p">,</span>
                                <span class="n">time_dependent</span><span class="o">=</span><span class="n">time_dependent</span><span class="p">,</span>
                                <span class="n">secular_relaxation</span><span class="o">=</span><span class="n">secular_relaxation</span><span class="p">,</span>
                                <span class="n">relaxation_cutoff_time</span><span class="o">=</span><span class="n">relaxation_cutoff_time</span><span class="p">,</span>
                                <span class="n">coupling_cutoff</span><span class="o">=</span><span class="n">coupling_cutoff</span><span class="p">,</span>
                                <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">)</span>
                <span class="c1"># if vibrational states are present, we create a new SBI</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we assume that we have only electronic sbi</span>
                    <span class="c1"># FIXME: make sure that Molecule also has Nel</span>
                    <span class="k">if</span> <span class="n">sbi</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">Nel</span> <span class="o">==</span> <span class="n">sbi</span><span class="o">.</span><span class="n">KK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># upgrade sbi to vibrational levels</span>
                        
                        <span class="n">eKK</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">.</span><span class="n">KK</span>
                        <span class="n">vKK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sbi</span><span class="o">.</span><span class="n">KK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">ham</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                        
                        <span class="c1"># use eKK to calculate vKK</span>
                        
                        <span class="n">sbi</span><span class="o">.</span><span class="n">KK</span> <span class="o">=</span> <span class="n">vKK</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;SystemBathInteraction object has to&quot;</span><span class="o">+</span>
                                        <span class="s2">&quot; purely electronic&quot;</span><span class="p">)</span>
                        
                    <span class="n">relaxT</span> <span class="o">=</span> <span class="n">LindbladForm</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">secular_relaxation</span><span class="p">:</span>
                    <span class="n">relaxT</span><span class="o">.</span><span class="n">convert_2_tensor</span><span class="p">()</span>
                    <span class="n">relaxT</span><span class="o">.</span><span class="n">secularize</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationTensor</span> <span class="o">=</span> <span class="n">relaxT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RelaxationHamiltonian</span> <span class="o">=</span> <span class="n">ham</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_relaxation_tensor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relaxation_theory</span> <span class="o">=</span> <span class="s2">&quot;Lindblad_form&quot;</span>
                
            <span class="k">return</span> <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham</span>

             
        <span class="k">else</span><span class="p">:</span>
            
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Theory not implemented&quot;</span><span class="p">)</span></div>
        
      
<div class="viewcode-block" id="AggregateBase.get_ReducedDensityMatrixPropagator"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_ReducedDensityMatrixPropagator">[docs]</a>    <span class="k">def</span> <span class="nf">get_ReducedDensityMatrixPropagator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeaxis</span><span class="p">,</span>
                       <span class="n">relaxation_theory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">time_dependent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">secular_relaxation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                       <span class="n">relaxation_cutoff_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">coupling_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">as_operators</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">recalculate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns propagator of the density matrix</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">ReducedDensityMatrixPropagator</span>
        <span class="kn">from</span> <span class="nn">..core.managers</span> <span class="k">import</span> <span class="n">eigenbasis_of</span>
        
            
        <span class="n">relaxT</span><span class="p">,</span> <span class="n">ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_RelaxationTensor</span><span class="p">(</span><span class="n">timeaxis</span><span class="p">,</span>
                       <span class="n">relaxation_theory</span><span class="o">=</span><span class="n">relaxation_theory</span><span class="p">,</span>
                       <span class="n">time_dependent</span><span class="o">=</span><span class="n">time_dependent</span><span class="p">,</span>
                       <span class="n">secular_relaxation</span><span class="o">=</span><span class="n">secular_relaxation</span><span class="p">,</span> 
                       <span class="n">relaxation_cutoff_time</span><span class="o">=</span><span class="n">relaxation_cutoff_time</span><span class="p">,</span>
                       <span class="n">coupling_cutoff</span><span class="o">=</span><span class="n">coupling_cutoff</span><span class="p">,</span>
                       <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">,</span>
                       <span class="n">as_operators</span><span class="o">=</span><span class="n">as_operators</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">ham</span><span class="p">):</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="n">ReducedDensityMatrixPropagator</span><span class="p">(</span><span class="n">timeaxis</span><span class="p">,</span> <span class="n">ham</span><span class="p">,</span> <span class="n">relaxT</span><span class="p">)</span>
            
        
        <span class="k">return</span> <span class="n">prop</span></div>

        
    <span class="c1">#FIXME: There must be a general theory here</span>
    <span class="k">def</span> <span class="nf">get_RedfieldRateMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="kn">from</span> <span class="nn">..qm</span> <span class="k">import</span> <span class="n">RedfieldRateMatrix</span>
        <span class="kn">from</span> <span class="nn">..core.managers</span> <span class="k">import</span> <span class="n">eigenbasis_of</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="n">ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Hamiltonian</span><span class="p">()</span>
            <span class="n">sbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SystemBathInteraction</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>        

        <span class="n">ham</span><span class="o">.</span><span class="n">protect_basis</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">ham</span><span class="p">):</span>
            <span class="n">RR</span> <span class="o">=</span> <span class="n">RedfieldRateMatrix</span><span class="p">(</span><span class="n">ham</span><span class="p">,</span> <span class="n">sbi</span><span class="p">)</span>
        <span class="n">ham</span><span class="o">.</span><span class="n">unprotect_basis</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">RR</span>

            
<div class="viewcode-block" id="AggregateBase.diagonalize"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.diagonalize">[docs]</a>    <span class="k">def</span> <span class="nf">diagonalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transforms some internal quantities into diagonal basis </span>
<span class="sd">           </span>
<span class="sd">        &quot;&quot;&quot;</span>
           
        <span class="n">ee</span><span class="p">,</span><span class="n">SS</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">HD</span> <span class="o">=</span> <span class="n">ee</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SS</span> <span class="o">=</span> <span class="n">SS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">SS</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">HH</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SS</span><span class="p">))</span>
        
        
        <span class="c1">#</span>
        <span class="c1"># some quantities to be precalculated for two-ex lineshape</span>
        <span class="c1"># 1-&gt;2 has to be trasformed first because we need untransformed 0-&gt;1</span>
        <span class="c1"># for such a transformation</span>
        <span class="c1">#</span>
        <span class="n">N1b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        
        <span class="c1">#  \kappa_{nA} = </span>
        <span class="c1">#  \sum_{K}(\delta_{nk}+\delta_{nl})*|\langle A | K\rangle|^2 </span>
        <span class="c1">#</span>
        <span class="c1">#  where K is a two-exc. state K = (k,l), A is a two-ex. state</span>
        <span class="c1">#  and n is a single exciton state</span>
        <span class="c1">#</span>
        <span class="c1">#  Below aa1 = A, aa2 = n, aa3 = K, st_k = k and st_l = l </span>
        <span class="c1">#</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
        <span class="c1"># Kronecker delta over all states</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">operator_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span><span class="p">)</span><span class="o">.</span><span class="n">unity_operator</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mult</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            
            <span class="n">N2b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="c1"># all states (and 2-ex band selected)</span>
            <span class="k">for</span> <span class="n">kk1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                <span class="n">el1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">kk1</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">el1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># all states corresponding to electronic two-exc. state kk</span>
                    <span class="k">for</span> <span class="n">aa1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">kk1</span><span class="p">]:</span>
                        
                        <span class="c1"># all states and (1-ex band selected)</span>
                        <span class="k">for</span> <span class="n">kk2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                            <span class="n">el2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">kk2</span><span class="p">]</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">el2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">aa2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">kk2</span><span class="p">]:</span>
                                    
                                    <span class="c1"># all states and (2-ex band selected)</span>
                                    <span class="k">for</span> <span class="n">kk3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">):</span>
                                        <span class="n">el3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elinds</span><span class="p">[</span><span class="n">kk3</span><span class="p">]</span>
                                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_band</span><span class="p">[</span><span class="n">el3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                            <span class="k">for</span> <span class="n">aa3</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibindices</span><span class="p">[</span><span class="n">kk3</span><span class="p">]:</span>
                                                <span class="n">st_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span><span class="p">[</span><span class="n">aa3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                                                <span class="n">st_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span><span class="p">[</span><span class="n">aa3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                                                <span class="n">kappa</span><span class="p">[</span><span class="n">aa2</span><span class="p">,</span> <span class="n">aa1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                                                     <span class="p">(</span><span class="n">delta</span><span class="p">[</span><span class="n">aa2</span><span class="p">,</span> <span class="n">st_k</span><span class="p">]</span> 
                                                    <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="n">aa2</span><span class="p">,</span> <span class="n">st_l</span><span class="p">])</span><span class="o">*</span>
                                                     <span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="n">aa3</span><span class="p">,</span> <span class="n">aa1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                                                     
            <span class="c1">#</span>
            <span class="c1"># Cross terms</span>
            <span class="c1">#</span>
            <span class="k">for</span> <span class="n">aa_2x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">,</span> <span class="n">N2b</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">aa_2x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">for</span> <span class="n">nn_2x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">,</span> <span class="n">N2b</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k_1x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">):</span>
                            <span class="n">st_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span><span class="p">[</span><span class="n">nn_2x</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">st_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span><span class="p">[</span><span class="n">nn_2x</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="c1">#print(st_n, st_m)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">aa_2x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]</span> <span class="o">+=</span> \
                                <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">st_n</span><span class="p">,</span> <span class="n">st_n</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span><span class="p">[</span><span class="n">st_n</span><span class="p">,</span> <span class="n">k_1x</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">st_m</span><span class="p">,</span> <span class="n">st_m</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span><span class="p">[</span><span class="n">st_m</span><span class="p">,</span> <span class="n">k_1x</span><span class="p">])</span><span class="o">*</span>\
                                 <span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="n">nn_2x</span><span class="p">,</span> <span class="n">aa_2x</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="n">k_1x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   
                                 
            <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">N1b</span><span class="p">:</span><span class="n">N2b</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">N1b</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">N1b</span><span class="p">:</span><span class="n">N2b</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">N1b</span><span class="p">])</span>
            <span class="c1">#print(self.Wd[N1b:N2b,0:N1b])</span>
            
            <span class="c1">#</span>
            <span class="c1"># Transform line shapes for 1-&gt;2 transitions</span>
            <span class="c1">#</span>
            <span class="n">Wd_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N2b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
            <span class="n">Dr_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N2b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>        
            <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">,</span> <span class="n">N2b</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">,</span> <span class="n">N2b</span><span class="p">):</span>
                    <span class="n">st_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">st_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twoex_indx</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">Wd_a</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span> <span class="n">aa</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span>\
                                <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">st_n</span><span class="p">,</span> <span class="n">st_n</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">kappa</span><span class="p">[</span><span class="n">st_n</span><span class="p">,</span> <span class="n">aa</span><span class="p">]</span>
                                <span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">st_m</span><span class="p">,</span> <span class="n">st_m</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">kappa</span><span class="p">[</span><span class="n">st_m</span><span class="p">,</span> <span class="n">aa</span><span class="p">])</span>
            <span class="n">W_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Wd_a</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">N1b</span><span class="p">:</span><span class="n">N2b</span><span class="p">,</span><span class="n">N1b</span><span class="p">:</span><span class="n">N2b</span><span class="p">]</span> <span class="o">=</span> <span class="n">W_aux</span><span class="p">[</span><span class="n">N1b</span><span class="p">:</span><span class="n">N2b</span><span class="p">,</span><span class="n">N1b</span><span class="p">:</span><span class="n">N2b</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Transform line shapes for 0-&gt;1 transitions</span>
        <span class="c1">#</span>
        <span class="n">Wd_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N1b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
        <span class="n">Dr_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N1b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N1b</span><span class="p">):</span>
                <span class="n">Wd_a</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">nn</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span>
                <span class="n">Dr_a</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dr</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">nn</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span>
        <span class="n">Wd_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Wd_a</span><span class="p">)</span>
        <span class="n">Dr_a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Dr_a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wd</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N1b</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">N1b</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Wd_a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N1b</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">N1b</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Dr_a</span><span class="p">)</span>
                                       
        
        <span class="c1">#</span>
        <span class="c1"># Transform transition dipole moments</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S1</span><span class="p">,</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">SS</span><span class="p">))</span>
        
        <span class="n">Ntot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dd2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ntot</span><span class="p">,</span><span class="n">Ntot</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ntot</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ntot</span><span class="p">):</span>
                <span class="n">dd2</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,:],</span><span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,:])</span>
        <span class="c1">#print(dd2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D2</span> <span class="o">=</span> <span class="n">dd2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D2_max</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dd2</span><span class="p">)</span></div>
        

    <span class="k">def</span> <span class="nf">_thermal_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temp</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">subtract</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                            <span class="n">relaxation_hamiltonian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Thermal populations at temperature temp</span>
<span class="sd">        </span>
<span class="sd">        Thermal populations calculated from the diagonal elements</span>
<span class="sd">        of the Hamiltonian.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        temp : float</span>
<span class="sd">            Temperature in Kelvins</span>
<span class="sd">            </span>
<span class="sd">        subtract : list like</span>
<span class="sd">            Reoreganization energies to subtract from the Hamiltonian</span>
<span class="sd">            </span>
<span class="sd">        relaxation_hamiltonian: array</span>
<span class="sd">            Hamiltonian according to which we form thermal equilibrium</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="kn">from</span> <span class="nn">..core.units</span> <span class="k">import</span> <span class="n">kB_intK</span>
        
        <span class="n">kBT</span> <span class="o">=</span> <span class="n">kB_intK</span><span class="o">*</span><span class="n">temp</span>
        
        <span class="c1">#if not relaxation_hamiltonian:</span>
        <span class="c1">#    HH = self.get_Hamiltonian()</span>
        <span class="c1">#else:</span>
        <span class="c1">#    HH = relaxation_hamiltonian</span>
        <span class="n">HH</span> <span class="o">=</span> <span class="n">relaxation_hamiltonian</span>
        
        <span class="c1"># This is all done with arrays, not with Qrhei objects</span>
        <span class="c1">#HH = HH.data</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">HH</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">subtract</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subtract</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
            
              
        <span class="k">if</span> <span class="n">temp</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">rho0</span><span class="p">[</span><span class="n">start</span><span class="p">,</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># FIXME: we assume only single exciton band</span>
        
            <span class="n">ens</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># we specify the basis from outside. This allows to choose </span>
            <span class="c1"># canonical equilibrium in arbitrary basis</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">ens</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">HH</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">subtract</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">start</span><span class="p">]</span> 
            
            <span class="n">ne</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ens</span><span class="o">/</span><span class="n">kBT</span><span class="p">)</span>
            <span class="n">sne</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ne</span><span class="p">)</span>
            <span class="n">rho0_diag</span> <span class="o">=</span> <span class="n">ne</span><span class="o">/</span><span class="n">sne</span>
            <span class="n">rho0</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span><span class="n">start</span><span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">rho0_diag</span><span class="p">)</span>
    
        
        <span class="k">return</span> <span class="n">rho0</span>

    
    <span class="k">def</span> <span class="nf">_impulsive_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relaxation_theory_limit</span><span class="o">=</span><span class="s2">&quot;weak_coupling&quot;</span><span class="p">,</span> 
                              <span class="n">temperature</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Impulsive excitation of the density matrix from ground state</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_DensityMatrix</span><span class="p">(</span><span class="n">condition_type</span><span class="o">=</span><span class="s2">&quot;thermal&quot;</span><span class="p">,</span> 
                            <span class="n">relaxation_theory_limit</span><span class="o">=</span><span class="n">relaxation_theory_limit</span><span class="p">,</span>
                            <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">data</span>
        
        <span class="n">DD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TrDMOp</span><span class="o">.</span><span class="n">data</span>
        
        <span class="c1"># abs value of the transition dipole moment</span>
        <span class="n">dabs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">DD</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                          <span class="n">DD</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">DD</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># excitation from bra and ket</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dabs</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span><span class="n">dabs</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">rho0</span>
        
        
<div class="viewcode-block" id="AggregateBase.get_DensityMatrix"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_DensityMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_DensityMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">relaxation_theory_limit</span><span class="o">=</span><span class="s2">&quot;weak_coupling&quot;</span><span class="p">,</span>
                                <span class="n">temperature</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">relaxation_hamiltonian</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns density matrix according to specified condition</span>
<span class="sd">        </span>
<span class="sd">        Returs density matrix to be used e.g. as initial condition for</span>
<span class="sd">        propagation.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        condition_type : str</span>
<span class="sd">            Type of the initial condition. If None, the property rho0, which </span>
<span class="sd">            was presumably calculated in the past, is returned.</span>
<span class="sd">            </span>
<span class="sd">        relaxation_theory_limits : str {weak_coupling, strong_coupling}</span>
<span class="sd">            Type of the relaxation theory limits; </span>
<span class="sd">            We mean the system bath coupling. When `weak_coupling` is chosen, </span>
<span class="sd">            the density matrix is returned in form of a canonical equilibrium </span>
<span class="sd">            in terms of the exciton basis. For `strong_coupling`, </span>
<span class="sd">            the canonical equilibrium is calculated in site basis with site </span>
<span class="sd">            energies striped of reorganization energies.</span>
<span class="sd">            </span>
<span class="sd">        temperature : float</span>
<span class="sd">            Temperature in Kelvin</span>
<span class="sd">            </span>
<span class="sd">        relaxation_hamiltonian : </span>
<span class="sd">            Hamiltonian according to which we form thermal equilibrium. In case</span>
<span class="sd">            of `strong_coupling`, no reorganization energies are subtracted -</span>
<span class="sd">            we assume that the supplied energies are already void of them.</span>
<span class="sd">            </span>
<span class="sd">        Condition types</span>
<span class="sd">        ---------------</span>
<span class="sd">        </span>
<span class="sd">        thermal </span>
<span class="sd">            Thermally equilibriated population of the whole density matrix</span>
<span class="sd">            </span>
<span class="sd">        thermal_excited_state </span>
<span class="sd">            Thermally equilibriuated excited state</span>
<span class="sd">            </span>
<span class="sd">        impulsive_excitation</span>
<span class="sd">            Excitation by ultrabroad laser pulse</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># aggregate must be built before we call this method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>

        <span class="c1"># if Aggregate has interaction with the bath, temperature </span>
        <span class="c1"># is already defined</span>
        <span class="k">if</span> <span class="n">temperature</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">temperature</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span><span class="o">.</span><span class="n">has_temperature</span><span class="p">():</span>
                <span class="n">temperature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span><span class="o">.</span><span class="n">get_temperature</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temperature</span> <span class="o">=</span> <span class="mf">0.0</span>
            
        <span class="c1"># if no condition is specified, it is understood that we return</span>
        <span class="c1"># internal rho0, which was calculated sometime in the past</span>
        <span class="k">if</span> <span class="n">condition_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho0</span><span class="p">)</span>
        
        
        <span class="c1"># impulsive excitation from a thermal ground state</span>
        <span class="k">elif</span> <span class="n">condition_type</span> <span class="o">==</span> <span class="s2">&quot;impulsive_excitation&quot;</span><span class="p">:</span>
            <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impulsive_population</span><span class="p">(</span>
                              <span class="n">relaxation_theory_limit</span><span class="o">=</span><span class="n">relaxation_theory_limit</span><span class="p">,</span> 
                              <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span> <span class="o">=</span> <span class="n">rho0</span>
            <span class="k">return</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho0</span><span class="p">)</span>
           
            
        <span class="c1"># thermal population based on the total Hamiltonian</span>
        <span class="k">elif</span> <span class="n">condition_type</span> <span class="o">==</span> <span class="s2">&quot;thermal&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">relaxation_hamiltonian</span><span class="p">:</span>
                <span class="n">Ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Hamiltonian</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ham</span> <span class="o">=</span> <span class="n">relaxation_hamiltonian</span>
            
            <span class="c1"># FIXME: weak and strong limits not distinguished</span>
            <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thermal_population</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> 
                                            <span class="n">relaxation_hamiltonian</span><span class="o">=</span><span class="n">Ham</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span> <span class="o">=</span> <span class="n">rho0</span>
            <span class="k">return</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho0</span><span class="p">)</span>            
        
        <span class="k">elif</span> <span class="n">condition_type</span> <span class="o">==</span> <span class="s2">&quot;thermal_excited_state&quot;</span><span class="p">:</span>
                            
            <span class="k">if</span> <span class="n">relaxation_theory_limit</span> <span class="o">==</span> <span class="s2">&quot;strong_coupling&quot;</span><span class="p">:</span>
                
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># this is where excited state starts</span>
                <span class="n">n1ex</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># number of excited states in one-ex band</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">relaxation_hamiltonian</span><span class="p">:</span>
                    <span class="n">HH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Hamiltonian</span><span class="p">()</span>
                    <span class="n">Ndim</span> <span class="o">=</span> <span class="n">HH</span><span class="o">.</span><span class="n">dim</span>
                    <span class="n">re</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ndim</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="c1"># we need to subtract reorganization energies</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1ex</span><span class="p">):</span>
                        <span class="n">re</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span><span class="o">.</span><span class="n">get_reorganization_energy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">HH</span> <span class="o">=</span> <span class="n">relaxation_hamiltonian</span>
                    <span class="n">Ndim</span> <span class="o">=</span> <span class="n">HH</span><span class="o">.</span><span class="n">dim</span>
                    <span class="n">re</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ndim</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="c1"># here we assume that reorganizaton energies are already</span>
                    <span class="c1"># removed</span>

                   
                <span class="c1"># we get this in SITE BASIS</span>
                <span class="n">ham</span> <span class="o">=</span> <span class="n">HH</span><span class="o">.</span><span class="n">data</span>
                
                <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thermal_population</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> 
                                                <span class="n">subtract</span><span class="o">=</span><span class="n">re</span><span class="p">,</span>
                                                <span class="n">relaxation_hamiltonian</span><span class="o">=</span><span class="n">ham</span><span class="p">,</span>
                                                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">relaxation_theory_limit</span> <span class="o">==</span> <span class="s2">&quot;weak_coupling&quot;</span><span class="p">:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">relaxation_hamiltonian</span><span class="p">:</span>
                    <span class="n">Ham</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Hamiltonian</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Ham</span> <span class="o">=</span> <span class="n">relaxation_hamiltonian</span>
                    
                <span class="c1"># we get this in EXCITON BASIS</span>
                <span class="k">with</span> <span class="n">qr</span><span class="o">.</span><span class="n">eigenbasis_of</span><span class="p">(</span><span class="n">Ham</span><span class="p">):</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="n">Ham</span><span class="o">.</span><span class="n">data</span>
                    
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># this is where excited state starts</span>
                
                <span class="c1"># we subtract lowest energy to ease the calcultion,</span>
                <span class="c1"># but we do not remove reorganization enegies</span>
                <span class="n">subt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">subtfil</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">H</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span> \
                                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]))</span>
                <span class="n">subt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">subtfil</span><span class="p">)</span> 
                
                <span class="n">rho0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thermal_population</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span>\
                            <span class="n">subtract</span> <span class="o">=</span> <span class="n">subt</span><span class="p">,</span>
                            <span class="n">relaxation_hamiltonian</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>
                            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown relaxation_theory_limit&quot;</span><span class="p">)</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">rho0</span> <span class="o">=</span> <span class="n">rho0</span>
            <span class="k">return</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho0</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown condition type&quot;</span><span class="p">)</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>

        
<div class="viewcode-block" id="AggregateBase.get_temperature"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_temperature">[docs]</a>    <span class="k">def</span> <span class="nf">get_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns temperature associated with this aggregate</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        The temperature originates from the system-bath interaction</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># aggregate must be built before we call this method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span><span class="o">.</span><span class="n">CC</span><span class="o">.</span><span class="n">get_temperature</span><span class="p">()</span></div>
        <span class="c1">#</span>
        <span class="c1"># TESTED</span>

   
<div class="viewcode-block" id="AggregateBase.get_electronic_groundstate"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_electronic_groundstate">[docs]</a>    <span class="k">def</span> <span class="nf">get_electronic_groundstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indices of states in electronic ground state</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Returns indices of all states in the electronic</span>
<span class="sd">        ground state of the system.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
           
        <span class="n">Ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ng</span><span class="p">)]</span>
           
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span></div>
        
    
<div class="viewcode-block" id="AggregateBase.get_excitonic_band"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_excitonic_band">[docs]</a>    <span class="k">def</span> <span class="nf">get_excitonic_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indices of states in a given excitonic band.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Returns indices of all states in the excitonic band </span>
<span class="sd">        with number of excitons equal to `band` </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        band : int</span>
<span class="sd">            Specifies which band should be returned.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">Nbefore</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band</span><span class="p">):</span>       
            <span class="n">Nbefore</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">Nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nb</span><span class="p">[</span><span class="n">band</span><span class="p">]</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nbefore</span><span class="p">,</span> <span class="n">Nbefore</span><span class="o">+</span><span class="n">Nin</span><span class="p">)]</span>
        
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="AggregateBase.get_transition"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_transition">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nf</span><span class="p">,</span> <span class="n">Ni</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns relevant info about the energetic transition</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Nf : {int, ElectronicState, VibronicState}</span>
<span class="sd">            Final state of the transition</span>
<span class="sd">            </span>
<span class="sd">        Ni : {int, ElectronicState VibronicState}</span>
<span class="sd">            Initial state of the transition</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Nf</span><span class="p">,</span> <span class="n">ElectronicState</span><span class="p">)</span> 
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">ElectronicState</span><span class="p">)):</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntot</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">:</span>
                <span class="n">iNf</span> <span class="o">=</span> <span class="n">Nf</span><span class="o">.</span><span class="n">index</span>
                <span class="n">iNi</span> <span class="o">=</span> <span class="n">Ni</span><span class="o">.</span><span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The Hamiltonian is not pure electronic&quot;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Nf</span><span class="p">,</span> <span class="n">VibronicState</span><span class="p">)</span> 
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">VibronicState</span><span class="p">)):</span>
            <span class="n">vsig</span> <span class="o">=</span> <span class="n">Nf</span><span class="o">.</span><span class="n">get_vibsignature</span><span class="p">()</span>
            <span class="n">esig</span> <span class="o">=</span> <span class="n">Nf</span><span class="o">.</span><span class="n">get_ElectronicState</span><span class="p">()</span><span class="o">.</span><span class="n">get_signature</span><span class="p">()</span>
            <span class="n">iNf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibsigs</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">esig</span><span class="p">,</span> <span class="n">vsig</span><span class="p">))</span>
            
            <span class="c1">#print(esig, vsig, iNf)</span>
            <span class="n">vsig</span> <span class="o">=</span> <span class="n">Ni</span><span class="o">.</span><span class="n">get_vibsignature</span><span class="p">()</span>
            <span class="n">esig</span> <span class="o">=</span> <span class="n">Ni</span><span class="o">.</span><span class="n">get_ElectronicState</span><span class="p">()</span><span class="o">.</span><span class="n">get_signature</span><span class="p">()</span>
            <span class="n">iNi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vibsigs</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">esig</span><span class="p">,</span> <span class="n">vsig</span><span class="p">))</span>
            <span class="c1">#print(esig, vsig, iNi)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iNf</span> <span class="o">=</span> <span class="n">Nf</span>
            <span class="n">iNi</span> <span class="o">=</span> <span class="n">Ni</span>
        
        <span class="c1">#</span>
        <span class="c1"># if Nf and Ni are not of the same type, it will lead to Exception</span>
        <span class="c1">#</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_energy_2_current_u</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="p">[</span><span class="n">iNf</span><span class="p">,</span><span class="n">iNf</span><span class="p">]</span>
                                                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">HH</span><span class="p">[</span><span class="n">iNi</span><span class="p">,</span><span class="n">iNi</span><span class="p">])</span>
        <span class="n">trdipm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">[</span><span class="n">iNf</span><span class="p">,</span><span class="n">iNi</span><span class="p">,:]</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">trdipm</span><span class="p">)</span></div>


<div class="viewcode-block" id="AggregateBase.get_SystemBathInteraction"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_SystemBathInteraction">[docs]</a>    <span class="k">def</span> <span class="nf">get_SystemBathInteraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the aggregate SystemBathInteraction object</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Aggregate object not built&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="AggregateBase.set_SystemBathInteraction"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.set_SystemBathInteraction">[docs]</a>    <span class="k">def</span> <span class="nf">set_SystemBathInteraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sbi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the SystemBathInteraction operator for this aggregate</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: check its compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">sbi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sbi</span><span class="o">.</span><span class="n">set_system</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
        


<div class="viewcode-block" id="AggregateBase.get_Hamiltonian"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_Hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">get_Hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the aggregate Hamiltonian</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">HamOp</span> <span class="c1">#Hamiltonian(data=self.HH) </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Aggregate object not built&quot;</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="AggregateBase.get_electronic_Hamiltonian"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_electronic_Hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">get_electronic_Hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the aggregate electronic Hamiltonian</span>
<span class="sd">        </span>
<span class="sd">        In case this is a purely electronic aggregate, the output</span>
<span class="sd">        is identical to get_Hamiltonian()</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">HH</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nel</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">qr</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sta</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elstates</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">):</span>
            <span class="n">HH</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span><span class="o">.</span><span class="n">energy</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">stb</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elstates</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mult</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">HH</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling</span><span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">stb</span><span class="p">)</span> 
        <span class="n">HHel</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">HH</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">HHel</span></div>
            

<div class="viewcode-block" id="AggregateBase.get_TransitionDipoleMoment"><a class="viewcode-back" href="../../../classes/aggregate.html#quantarhei.builders.aggregate_base.AggregateBase.get_TransitionDipoleMoment">[docs]</a>    <span class="k">def</span> <span class="nf">get_TransitionDipoleMoment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the aggregate transition dipole moment operator</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_built</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TransitionDipoleMoment</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">DD</span><span class="p">)</span>                     
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Aggregate object not built&quot;</span><span class="p">)</span></div></div>
            
            
            
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Quantarhei 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2018 Tomas Mancal.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>